["^ ","~:output",["^ ","~:js","goog.provide('com.fulcrologic.fulcro.algorithms.merge');\ngoog.require('cljs.core');\ngoog.require('com.fulcrologic.fulcro.algorithms.data_targeting');\ngoog.require('com.fulcrologic.fulcro.components');\ngoog.require('com.fulcrologic.fulcro.algorithms.lookup');\ngoog.require('com.fulcrologic.fulcro.algorithms.normalize');\ngoog.require('com.fulcrologic.fulcro.algorithms.denormalize');\ngoog.require('com.fulcrologic.fulcro.algorithms.do_not_use');\ngoog.require('edn_query_language.core');\ngoog.require('taoensso.timbre');\n/**\n * Removes an ident, if it exists, from a list of idents in app state. This\n *   function is safe to use within mutations.\n */\ncom.fulcrologic.fulcro.algorithms.merge.remove_ident_STAR_ = (function com$fulcrologic$fulcro$algorithms$merge$remove_ident_STAR_(state_map,ident,path_to_idents){\nif(cljs.core.map_QMARK_(state_map)){\n} else {\nthrow (new Error(\"Assert failed: (map? state-map)\"));\n}\n\nvar new_list = (function (old_list){\nreturn cljs.core.vec(cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (p1__63801_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(ident,p1__63801_SHARP_);\n}),old_list));\n});\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$3(state_map,path_to_idents,new_list);\n});\n/**\n * Check the given keyword to see if it is in the :ui namespace.\n */\ncom.fulcrologic.fulcro.algorithms.merge.is_ui_query_fragment_QMARK_ = (function com$fulcrologic$fulcro$algorithms$merge$is_ui_query_fragment_QMARK_(kw){\nvar kw__$1 = ((cljs.core.map_QMARK_(kw))?cljs.core.first(cljs.core.keys(kw)):kw);\nif((kw__$1 instanceof cljs.core.Keyword)){\nvar G__63805 = kw__$1;\nvar G__63805__$1 = (((G__63805 == null))?null:cljs.core.namespace(G__63805));\nif((G__63805__$1 == null)){\nreturn null;\n} else {\nreturn cljs.core.re_find(/^ui(?:\\.|$)/,G__63805__$1);\n}\n} else {\nreturn null;\n}\n});\n/**\n * Returns true if the `k` in `props` is the sweep-merge not-found marker. This marker appears\n *   *during* merge, and can affect `:pre-merge` processing, since the data-tree will have these\n *   markers when the given data is missing.\n */\ncom.fulcrologic.fulcro.algorithms.merge.not_found_QMARK_ = (function com$fulcrologic$fulcro$algorithms$merge$not_found_QMARK_(props,k){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),cljs.core.get.cljs$core$IFn$_invoke$arity$2(props,k));\n});\n/**\n * Given x, return x value unless it's ::not-found (the mark/sweep missing marker), in which case it returns nil.\n * \n *   This is useful when you are pre-processing a tree that has been marked for missing data sweep (see `mark-missing`),\n *   but has not yet been swept. This is basically the same as a `nil?` check in this circumstance since the given\n *   value will be removed after the final sweep.\n */\ncom.fulcrologic.fulcro.algorithms.merge.nilify_not_found = (function com$fulcrologic$fulcro$algorithms$merge$nilify_not_found(x){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437))){\nreturn null;\n} else {\nreturn x;\n}\n});\n/**\n * Returns `data` with meta-data that marks it as a leaf in the result.\n */\ncom.fulcrologic.fulcro.algorithms.merge.as_leaf = (function com$fulcrologic$fulcro$algorithms$merge$as_leaf(data){\nif(cljs.core.coll_QMARK_(data)){\nreturn cljs.core.with_meta(data,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"fulcro\",\"leaf\",\"fulcro/leaf\",-2094500471),true], null));\n} else {\nreturn data;\n}\n});\n/**\n * Returns true iff the given data is marked as a leaf in the result (according to the query). Requires pre-marking.\n */\ncom.fulcrologic.fulcro.algorithms.merge.leaf_QMARK_ = (function com$fulcrologic$fulcro$algorithms$merge$leaf_QMARK_(data){\nreturn (((!(cljs.core.coll_QMARK_(data)))) || (cljs.core.empty_QMARK_(data)) || (((cljs.core.coll_QMARK_(data)) && (cljs.core.boolean$(new cljs.core.Keyword(\"fulcro\",\"leaf\",\"fulcro/leaf\",-2094500471).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(data)))))));\n});\n/**\n * Turn a union query into a query that attempts to encompass all possible things that might be queried.\n */\ncom.fulcrologic.fulcro.algorithms.merge.union__GT_query = (function com$fulcrologic$fulcro$algorithms$merge$union__GT_query(union_query){\nreturn cljs.core.vec(cljs.core.set(cljs.core.flatten(cljs.core.vals(union_query))));\n});\n/**\n * Recursively walk the query and response marking anything that was *asked for* in the query but is *not* in the response as missing.\n *   The sweep-merge process (which happens later in the plumbing) uses these markers as indicators to remove any existing\n *   data in the target of the merge (i.e. your state database).\n * \n *   The naive approach to data merging (even recursive) would fail to remove such data.\n * \n *   Returns the result with missing markers in place (which are then used/removed in a later stage).\n * \n *   See the Developer Guide section on Fulcro's merge process for more information.\n */\ncom.fulcrologic.fulcro.algorithms.merge.mark_missing = (function com$fulcrologic$fulcro$algorithms$merge$mark_missing(result,query){\nvar missing_entity = new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (missing_entity){\nreturn (function (result__$1,element){\nvar element__$1 = ((cljs.core.list_QMARK_(element))?cljs.core.first(element):element\n);\nvar result_key = (((element__$1 instanceof cljs.core.Keyword))?element__$1:((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(element__$1))?com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1):null\n));\nvar result_value = cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,result_key);\nif(((((edn_query_language.core.ident_QMARK_(result_key)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Symbol(null,\"_\",\"_\",-1201019570,null),cljs.core.second(result_key))))) || (((edn_query_language.core.ident_QMARK_(element__$1)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Symbol(null,\"_\",\"_\",-1201019570,null),cljs.core.second(element__$1))))))){\nreturn result__$1;\n} else {\nif(cljs.core.truth_(com.fulcrologic.fulcro.algorithms.merge.is_ui_query_fragment_QMARK_(result_key))){\nreturn result__$1;\n} else {\nif((((element__$1 instanceof cljs.core.Keyword)) && ((cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,element__$1) == null)))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,element__$1,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\n} else {\nif(((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(element__$1)) && (((typeof com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1) === 'number') || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Symbol(null,\"...\",\"...\",-1926939749,null),com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1))))))){\nvar k = com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1);\nvar result_SINGLEQUOTE_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,k);\nif((result_SINGLEQUOTE_ == null)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,k,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\n} else {\nif(cljs.core.vector_QMARK_(result_SINGLEQUOTE_)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,k,cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(((function (k,result_SINGLEQUOTE_,element__$1,result_key,result_value,missing_entity){\nreturn (function (item){\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2(item,query) : com.fulcrologic.fulcro.algorithms.merge.mark_missing.call(null,item,query));\n});})(k,result_SINGLEQUOTE_,element__$1,result_key,result_value,missing_entity))\n,result_SINGLEQUOTE_));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,k,(com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2(result_SINGLEQUOTE_,query) : com.fulcrologic.fulcro.algorithms.merge.mark_missing.call(null,result_SINGLEQUOTE_,query)));\n\n}\n}\n} else {\nif(((edn_query_language.core.ident_QMARK_(element__$1)) && ((cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,element__$1) == null)))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,element__$1,missing_entity);\n} else {\nif(com.fulcrologic.fulcro.algorithms.do_not_use.union_QMARK_(element__$1)){\nvar v = cljs.core.get.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\nvar to_one_QMARK_ = cljs.core.map_QMARK_(v);\nvar to_many_QMARK_ = cljs.core.vector_QMARK_(v);\nvar wide_query = com.fulcrologic.fulcro.algorithms.merge.union__GT_query(com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1));\nif(to_one_QMARK_){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,(com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2(v,wide_query) : com.fulcrologic.fulcro.algorithms.merge.mark_missing.call(null,v,wide_query)));\n} else {\nif(to_many_QMARK_){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(((function (v,to_one_QMARK_,to_many_QMARK_,wide_query,element__$1,result_key,result_value,missing_entity){\nreturn (function (i){\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2(i,wide_query) : com.fulcrologic.fulcro.algorithms.merge.mark_missing.call(null,i,wide_query));\n});})(v,to_one_QMARK_,to_many_QMARK_,wide_query,element__$1,result_key,result_value,missing_entity))\n,v));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),v)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\n} else {\nreturn result__$1;\n\n}\n}\n}\n} else {\nif(((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(element__$1)) && (edn_query_language.core.ident_QMARK_(com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1))) && ((cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1)) == null)))){\nvar mock_missing_object = (function (){var G__63824 = cljs.core.PersistentArrayMap.EMPTY;\nvar G__63825 = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1);\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2(G__63824,G__63825) : com.fulcrologic.fulcro.algorithms.merge.mark_missing.call(null,G__63824,G__63825));\n})();\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1),cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([mock_missing_object,missing_entity], 0)));\n} else {\nif(((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(element__$1)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),cljs.core.get.cljs$core$IFn$_invoke$arity$3(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1),new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437)))))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1),new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\n} else {\nif(((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(element__$1)) && (cljs.core.vector_QMARK_(cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1)))))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1),cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(((function (element__$1,result_key,result_value,missing_entity){\nreturn (function (item){\nvar G__63827 = item;\nvar G__63828 = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1);\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2(G__63827,G__63828) : com.fulcrologic.fulcro.algorithms.merge.mark_missing.call(null,G__63827,G__63828));\n});})(element__$1,result_key,result_value,missing_entity))\n,cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1))));\n} else {\nif(((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(element__$1)) && (cljs.core.map_QMARK_(cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1)))))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1),(function (){var G__63829 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1));\nvar G__63830 = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1);\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2(G__63829,G__63830) : com.fulcrologic.fulcro.algorithms.merge.mark_missing.call(null,G__63829,G__63830));\n})());\n} else {\nif(((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(element__$1)) && (cljs.core.vector_QMARK_(com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1))) && ((!(((cljs.core.map_QMARK_(result_value)) || (cljs.core.vector_QMARK_(result_value)))))))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,(function (){var G__63834 = cljs.core.PersistentArrayMap.EMPTY;\nvar G__63835 = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1);\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing.cljs$core$IFn$_invoke$arity$2(G__63834,G__63835) : com.fulcrologic.fulcro.algorithms.merge.mark_missing.call(null,G__63834,G__63835));\n})());\n} else {\nif(cljs.core.truth_(result_key)){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,com.fulcrologic.fulcro.algorithms.merge.as_leaf);\n} else {\nreturn result__$1;\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});})(missing_entity))\n,result,query);\n});\n/**\n * Remove not-found keys from m (non-recursive). `m` can be a map (sweep the values) or vector (run sweep-one on each entry).\n */\ncom.fulcrologic.fulcro.algorithms.merge.sweep_one = (function com$fulcrologic$fulcro$algorithms$merge$sweep_one(m){\nif(cljs.core.map_QMARK_(m)){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,p__63836){\nvar vec__63839 = p__63836;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63839,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63839,(1),null);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),k)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),v)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"tempids\",\"tempids\",1767509089),k)))){\nreturn acc;\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,k,v);\n}\n}),cljs.core.with_meta(cljs.core.PersistentArrayMap.EMPTY,cljs.core.meta(m)),m);\n} else {\nif(cljs.core.vector_QMARK_(m)){\nreturn cljs.core.with_meta(cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(com.fulcrologic.fulcro.algorithms.merge.sweep_one,m),cljs.core.meta(m));\n} else {\nreturn m;\n\n}\n}\n});\n/**\n * Remove all of the not-found keys (recursively) from m, stopping at marked leaves (if present). Requires `m`\n *   to have been pre-marked via `mark-missing`.\n */\ncom.fulcrologic.fulcro.algorithms.merge.sweep = (function com$fulcrologic$fulcro$algorithms$merge$sweep(m){\nif(com.fulcrologic.fulcro.algorithms.merge.leaf_QMARK_(m)){\nreturn com.fulcrologic.fulcro.algorithms.merge.sweep_one(m);\n} else {\nif(cljs.core.map_QMARK_(m)){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,p__63843){\nvar vec__63844 = p__63843;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63844,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63844,(1),null);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),k)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),v)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"tempids\",\"tempids\",1767509089),k)))){\nreturn acc;\n} else {\nif(((edn_query_language.core.ident_QMARK_(v)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),cljs.core.second(v))))){\nreturn acc;\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,k,(com.fulcrologic.fulcro.algorithms.merge.sweep.cljs$core$IFn$_invoke$arity$1 ? com.fulcrologic.fulcro.algorithms.merge.sweep.cljs$core$IFn$_invoke$arity$1(v) : com.fulcrologic.fulcro.algorithms.merge.sweep.call(null,v)));\n\n}\n}\n}),cljs.core.with_meta(cljs.core.PersistentArrayMap.EMPTY,cljs.core.meta(m)),m);\n} else {\nif(cljs.core.vector_QMARK_(m)){\nreturn cljs.core.with_meta(cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(com.fulcrologic.fulcro.algorithms.merge.sweep,m),cljs.core.meta(m));\n} else {\nreturn m;\n\n}\n}\n}\n});\n/**\n * Do a recursive merge of source into target (both maps), but remove any target data that is marked as missing in the response.\n * \n *   Requires that the `source` has been marked via `mark-missing`.\n * \n *   The missing marker is generated in the source when something has been asked for in the query, but had no value in the\n *   response. This allows us to correctly remove 'empty' data from the database without accidentally removing something\n *   that may still exist on the server (in truth we don't know its status, since it wasn't asked for, but we leave\n *   it as our 'best guess').\n */\ncom.fulcrologic.fulcro.algorithms.merge.sweep_merge = (function com$fulcrologic$fulcro$algorithms$merge$sweep_merge(target,source){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,p__63850){\nvar vec__63851 = p__63850;\nvar key = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63851,(0),null);\nvar new_value = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63851,(1),null);\nvar existing_value = cljs.core.get.cljs$core$IFn$_invoke$arity$2(acc,key);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(key,new cljs.core.Keyword(null,\"tempids\",\"tempids\",1767509089))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(key,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437))))){\nreturn acc;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new_value,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437))){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(acc,key);\n} else {\nif(((edn_query_language.core.ident_QMARK_(new_value)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),cljs.core.second(new_value))))){\nreturn acc;\n} else {\nif(com.fulcrologic.fulcro.algorithms.merge.leaf_QMARK_(new_value)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,key,com.fulcrologic.fulcro.algorithms.merge.sweep_one(new_value));\n} else {\nif(((cljs.core.map_QMARK_(existing_value)) && (cljs.core.map_QMARK_(new_value)))){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(acc,key,com.fulcrologic.fulcro.algorithms.merge.sweep_merge,new_value);\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,key,com.fulcrologic.fulcro.algorithms.merge.sweep(new_value));\n\n}\n}\n}\n}\n}\n}),target,source);\n});\ncom.fulcrologic.fulcro.algorithms.merge.component_pre_merge = (function com$fulcrologic$fulcro$algorithms$merge$component_pre_merge(class$,query,state,data,p__63857){\nvar map__63858 = p__63857;\nvar map__63858__$1 = (((((!((map__63858 == null))))?(((((map__63858.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__63858.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__63858):map__63858);\nvar remove_missing_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63858__$1,new cljs.core.Keyword(null,\"remove-missing?\",\"remove-missing?\",-2044119224));\nif(com.fulcrologic.fulcro.components.has_pre_merge_QMARK_(class$)){\nvar entity = (function (){var G__63863 = com.fulcrologic.fulcro.components.get_ident.cljs$core$IFn$_invoke$arity$2(class$,data);\nif((G__63863 == null)){\nreturn null;\n} else {\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(state,G__63863);\n}\n})();\nvar unmarked_data = (cljs.core.truth_(remove_missing_QMARK_)?com.fulcrologic.fulcro.algorithms.merge.sweep_merge(cljs.core.PersistentArrayMap.EMPTY,data):data);\nvar unmarked_result = com.fulcrologic.fulcro.components.pre_merge(class$,new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"state-map\",\"state-map\",-1313872128),state,new cljs.core.Keyword(null,\"current-normalized\",\"current-normalized\",851723724),entity,new cljs.core.Keyword(null,\"data-tree\",\"data-tree\",1311167582),unmarked_data,new cljs.core.Keyword(null,\"query\",\"query\",-1288509510),query], null));\nvar result = (cljs.core.truth_(remove_missing_QMARK_)?com.fulcrologic.fulcro.algorithms.merge.mark_missing(unmarked_result,query):unmarked_result);\nreturn result;\n} else {\nreturn data;\n}\n});\n/**\n * Transform function that modifies data using component pre-merge hook.\n */\ncom.fulcrologic.fulcro.algorithms.merge.pre_merge_transform = (function com$fulcrologic$fulcro$algorithms$merge$pre_merge_transform(var_args){\nvar G__63865 = arguments.length;\nswitch (G__63865) {\ncase 1:\nreturn com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$1 = (function (state){\nreturn com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2(state,cljs.core.PersistentArrayMap.EMPTY);\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2 = (function (state,options){\nreturn (function com$fulcrologic$fulcro$algorithms$merge$pre_merge_transform_internal(query,data){\nvar temp__5751__auto__ = new cljs.core.Keyword(null,\"component\",\"component\",1555936782).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(query));\nif(cljs.core.truth_(temp__5751__auto__)){\nvar class$ = temp__5751__auto__;\nreturn com.fulcrologic.fulcro.algorithms.merge.component_pre_merge(class$,query,state,data,options);\n} else {\nreturn data;\n}\n});\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$lang$maxFixedArity = 2;\n\n/**\n * Merge all of the mutations that were joined with a query.\n * \n *   The options, if supplied, can include:\n * \n *   * `:remove-missing?`: (default false) If true then any items that appear in the `query` but not in the\n *   `data-tree` will be removed from `state` (if present).\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins = (function com$fulcrologic$fulcro$algorithms$merge$merge_mutation_joins(var_args){\nvar G__63873 = arguments.length;\nswitch (G__63873) {\ncase 3:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$3 = (function (state,query,data_tree){\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4(state,query,data_tree,cljs.core.PersistentArrayMap.EMPTY);\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4 = (function (state,query,data_tree,p__63874){\nvar map__63875 = p__63874;\nvar map__63875__$1 = (((((!((map__63875 == null))))?(((((map__63875.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__63875.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__63875):map__63875);\nvar options = map__63875__$1;\nvar remove_missing_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63875__$1,new cljs.core.Keyword(null,\"remove-missing?\",\"remove-missing?\",-2044119224));\nif(cljs.core.map_QMARK_(data_tree)){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (map__63875,map__63875__$1,options,remove_missing_QMARK_){\nreturn (function (updated_state,query_element){\nvar k = (function (){var and__4120__auto__ = com.fulcrologic.fulcro.algorithms.do_not_use.mutation_join_QMARK_(query_element);\nif(and__4120__auto__){\nreturn com.fulcrologic.fulcro.algorithms.do_not_use.join_key(query_element);\n} else {\nreturn and__4120__auto__;\n}\n})();\nvar subtree = cljs.core.get.cljs$core$IFn$_invoke$arity$2(data_tree,k);\nif(cljs.core.truth_((function (){var and__4120__auto__ = k;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn subtree;\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar subquery = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(query_element);\nvar target = new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.data-targeting\",\"target\",\"com.fulcrologic.fulcro.algorithms.data-targeting/target\",-1540673140).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(subquery));\nvar idnt = new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"temporary-key\",\"com.fulcrologic.fulcro.algorithms.merge/temporary-key\",-1065335624);\nvar norm_query = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentArrayMap.createAsIfByAssoc([idnt,subquery])], null);\nvar norm_tree = cljs.core.PersistentArrayMap.createAsIfByAssoc([idnt,subtree]);\nvar norm_tree_marked = (cljs.core.truth_(remove_missing_QMARK_)?com.fulcrologic.fulcro.algorithms.merge.mark_missing(norm_tree,norm_query):norm_tree);\nvar db = com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db.cljs$core$IFn$_invoke$arity$4(norm_query,norm_tree_marked,true,com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2(state,options));\nvar G__63880 = com.fulcrologic.fulcro.algorithms.merge.sweep_merge(updated_state,db);\nvar G__63880__$1 = (cljs.core.truth_(target)?com.fulcrologic.fulcro.algorithms.data_targeting.process_target.cljs$core$IFn$_invoke$arity$3(G__63880,idnt,target):G__63880);\nif(cljs.core.not(target)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(G__63880__$1,db,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([idnt], 0));\n} else {\nreturn G__63880__$1;\n}\n} else {\nreturn updated_state;\n}\n});})(map__63875,map__63875__$1,options,remove_missing_QMARK_))\n,state,query);\n} else {\nreturn state;\n}\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$lang$maxFixedArity = 4;\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_ident = (function com$fulcrologic$fulcro$algorithms$merge$merge_ident(app_state,ident,props){\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$4(app_state,ident,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(com.fulcrologic.fulcro.algorithms.merge.sweep_one,cljs.core.merge),props);\n});\ncom.fulcrologic.fulcro.algorithms.merge.sift_idents = (function com$fulcrologic$fulcro$algorithms$merge$sift_idents(res){\nvar map__63885 = cljs.core.group_by((function (p1__63884_SHARP_){\nreturn cljs.core.vector_QMARK_(cljs.core.first(p1__63884_SHARP_));\n}),res);\nvar map__63885__$1 = (((((!((map__63885 == null))))?(((((map__63885.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__63885.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__63885):map__63885);\nvar idents = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63885__$1,true);\nvar rest = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63885__$1,false);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,idents),cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,rest)], null);\n});\n/**\n * Handle merging incoming data and sweep it of values that are marked missing. This function also ensures that raw\n * mutation join results are ignored (they must be merged via `merge-mutation-joins`).\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_tree = (function com$fulcrologic$fulcro$algorithms$merge$merge_tree(target,source){\nvar source_to_merge = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentArrayMap.EMPTY,cljs.core.filter.cljs$core$IFn$_invoke$arity$1((function (p__63890){\nvar vec__63891 = p__63890;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63891,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63891,(1),null);\nreturn (!((k instanceof cljs.core.Symbol)));\n})),source);\nreturn com.fulcrologic.fulcro.algorithms.merge.sweep_merge(target,source_to_merge);\n});\n/**\n * Merge the given `refs` (a map from ident to props), query (a query that contains ident-joins), and tree:\n * \n *   returns a new tree with the data merged into the proper ident-based tables.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_idents = (function com$fulcrologic$fulcro$algorithms$merge$merge_idents(tree,query,refs,p__63896){\nvar map__63897 = p__63896;\nvar map__63897__$1 = (((((!((map__63897 == null))))?(((((map__63897.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__63897.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__63897):map__63897);\nvar options = map__63897__$1;\nvar remove_missing_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63897__$1,new cljs.core.Keyword(null,\"remove-missing?\",\"remove-missing?\",-2044119224));\nvar ident_joins = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentArrayMap.EMPTY,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$1(((function (map__63897,map__63897__$1,options,remove_missing_QMARK_){\nreturn (function (p1__63894_SHARP_){\nvar G__63902 = p1__63894_SHARP_;\nif(cljs.core.seq_QMARK_(p1__63894_SHARP_)){\nreturn cljs.core.first(G__63902);\n} else {\nreturn G__63902;\n}\n});})(map__63897,map__63897__$1,options,remove_missing_QMARK_))\n),cljs.core.filter.cljs$core$IFn$_invoke$arity$1(((function (map__63897,map__63897__$1,options,remove_missing_QMARK_){\nreturn (function (p1__63895_SHARP_){\nreturn ((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(p1__63895_SHARP_)) && (edn_query_language.core.ident_QMARK_(com.fulcrologic.fulcro.algorithms.do_not_use.join_key(p1__63895_SHARP_))));\n});})(map__63897,map__63897__$1,options,remove_missing_QMARK_))\n)),query);\nvar step = ((function (ident_joins,map__63897,map__63897__$1,options,remove_missing_QMARK_){\nreturn (function com$fulcrologic$fulcro$algorithms$merge$merge_idents_$_step(result_tree,p__63909){\nvar vec__63911 = p__63909;\nvar ident = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63911,(0),null);\nvar props = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63911,(1),null);\nvar component_query = cljs.core.get.cljs$core$IFn$_invoke$arity$3(ident_joins,ident,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"*\",\"*\",345799209,null)], null));\nvar marked_props = (cljs.core.truth_(remove_missing_QMARK_)?com.fulcrologic.fulcro.algorithms.merge.mark_missing(props,component_query):props);\nvar normalized_data = com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db.cljs$core$IFn$_invoke$arity$4(component_query,marked_props,false,com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2(tree,options));\nvar refs__$1 = cljs.core.meta(normalized_data);\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_tree(com.fulcrologic.fulcro.algorithms.merge.merge_ident(result_tree,ident,normalized_data),refs__$1);\n});})(ident_joins,map__63897,map__63897__$1,options,remove_missing_QMARK_))\n;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(step,tree,refs);\n});\n/**\n * Merge the query-result of a query using Fulcro's standard merge and normalization logic.\n * \n *   Typically used on the state atom as:\n * \n *   ```\n *   (swap! state merge* query-result query)\n *   ```\n * \n *   - `state-map` - The normalized database.\n *   - `query` - The query that was used to obtain the query-result. This query will be treated relative to the root of the database.\n *   - `tree` - The query-result to merge (a map).\n * \n *   The options is a map containing:\n * \n *   * `:remove-missing?` If true (default false) then anything appearing in the `query` but not the `result-tree`\n *   will be removed from `state-map`.\n * \n *   See `merge-component` and `merge-component!` for possibly more appropriate functions for your task.\n * \n *   Returns the new normalized database.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_STAR_ = (function com$fulcrologic$fulcro$algorithms$merge$merge_STAR_(var_args){\nvar G__63915 = arguments.length;\nswitch (G__63915) {\ncase 3:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$3 = (function (state_map,query,result_tree){\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4(state_map,query,result_tree,cljs.core.PersistentArrayMap.EMPTY);\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4 = (function (state_map,query,result_tree,p__63920){\nvar map__63921 = p__63920;\nvar map__63921__$1 = (((((!((map__63921 == null))))?(((((map__63921.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__63921.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__63921):map__63921);\nvar options = map__63921__$1;\nvar remove_missing_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63921__$1,new cljs.core.Keyword(null,\"remove-missing?\",\"remove-missing?\",-2044119224));\nvar vec__63923 = com.fulcrologic.fulcro.algorithms.merge.sift_idents(result_tree);\nvar idts = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63923,(0),null);\nvar result_tree__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63923,(1),null);\nvar normalized_result = com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db.cljs$core$IFn$_invoke$arity$4(query,result_tree__$1,true,com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2(state_map,options));\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_tree(com.fulcrologic.fulcro.algorithms.merge.merge_idents(com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4(state_map,query,result_tree__$1,options),query,idts,options),normalized_result);\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$lang$maxFixedArity = 4;\n\n/**\n * Calculates the query that can be used to pull (or merge) a component with an ident\n *   to/from a normalized app database. Requires a tree of data that represents the instance of\n *   the component in question (e.g. ident will work on it)\n */\ncom.fulcrologic.fulcro.algorithms.merge.component_merge_query = (function com$fulcrologic$fulcro$algorithms$merge$component_merge_query(state_map,component,object_data){\nvar ident = com.fulcrologic.fulcro.components.ident(component,object_data);\nvar object_query = com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$2(component,state_map);\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentArrayMap.createAsIfByAssoc([ident,object_query])], null);\n});\n/**\n * Walks the given query and calls (merge-fn parent-union-component union-child-initial-state) for each non-default element of a union that has initial app state.\n *   You probably want to use merge-alternate-union-elements[!] on a state map or app.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_alternate_unions = (function com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions(merge_fn,root_component){\nvar walk_ast = (function() {\nvar com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast = null;\nvar com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__2 = (function (ast,visitor){\nreturn com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,null);\n});\nvar com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__3 = (function (p__63945,visitor,parent_union){\nvar map__63946 = p__63945;\nvar map__63946__$1 = (((((!((map__63946 == null))))?(((((map__63946.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__63946.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__63946):map__63946);\nvar parent_ast = map__63946__$1;\nvar children = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63946__$1,new cljs.core.Keyword(null,\"children\",\"children\",-940561982));\nvar component = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63946__$1,new cljs.core.Keyword(null,\"component\",\"component\",1555936782));\nvar type = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63946__$1,new cljs.core.Keyword(null,\"type\",\"type\",1174270348));\nvar dispatch_key = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63946__$1,new cljs.core.Keyword(null,\"dispatch-key\",\"dispatch-key\",733619510));\nvar union_key = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63946__$1,new cljs.core.Keyword(null,\"union-key\",\"union-key\",1529707234));\nvar key = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63946__$1,new cljs.core.Keyword(null,\"key\",\"key\",-1516042587));\nif(cljs.core.truth_((function (){var and__4120__auto__ = component;\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = parent_union;\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"union-entry\",\"union-entry\",223335750),type);\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\n(visitor.cljs$core$IFn$_invoke$arity$2 ? visitor.cljs$core$IFn$_invoke$arity$2(component,parent_union) : visitor.call(null,component,parent_union));\n} else {\n}\n\nif(cljs.core.truth_(children)){\nvar seq__63951 = cljs.core.seq(children);\nvar chunk__63952 = null;\nvar count__63953 = (0);\nvar i__63954 = (0);\nwhile(true){\nif((i__63954 < count__63953)){\nvar ast = chunk__63952.cljs$core$IIndexed$_nth$arity$2(null,i__63954);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(ast),new cljs.core.Keyword(null,\"union\",\"union\",2142937499))){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,component);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(ast),new cljs.core.Keyword(null,\"union-entry\",\"union-entry\",223335750))){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,parent_union);\n} else {\nif(cljs.core.truth_(ast)){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,null);\n} else {\n}\n}\n}\n\n\nvar G__64108 = seq__63951;\nvar G__64109 = chunk__63952;\nvar G__64110 = count__63953;\nvar G__64111 = (i__63954 + (1));\nseq__63951 = G__64108;\nchunk__63952 = G__64109;\ncount__63953 = G__64110;\ni__63954 = G__64111;\ncontinue;\n} else {\nvar temp__5753__auto__ = cljs.core.seq(seq__63951);\nif(temp__5753__auto__){\nvar seq__63951__$1 = temp__5753__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__63951__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__63951__$1);\nvar G__64114 = cljs.core.chunk_rest(seq__63951__$1);\nvar G__64115 = c__4550__auto__;\nvar G__64116 = cljs.core.count(c__4550__auto__);\nvar G__64117 = (0);\nseq__63951 = G__64114;\nchunk__63952 = G__64115;\ncount__63953 = G__64116;\ni__63954 = G__64117;\ncontinue;\n} else {\nvar ast = cljs.core.first(seq__63951__$1);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(ast),new cljs.core.Keyword(null,\"union\",\"union\",2142937499))){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,component);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(ast),new cljs.core.Keyword(null,\"union-entry\",\"union-entry\",223335750))){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,parent_union);\n} else {\nif(cljs.core.truth_(ast)){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,null);\n} else {\n}\n}\n}\n\n\nvar G__64118 = cljs.core.next(seq__63951__$1);\nvar G__64119 = null;\nvar G__64120 = (0);\nvar G__64121 = (0);\nseq__63951 = G__64118;\nchunk__63952 = G__64119;\ncount__63953 = G__64120;\ni__63954 = G__64121;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast = function(p__63945,visitor,parent_union){\nswitch(arguments.length){\ncase 2:\nreturn com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__2.call(this,p__63945,visitor);\ncase 3:\nreturn com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__3.call(this,p__63945,visitor,parent_union);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$2 = com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__2;\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3 = com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__3;\nreturn com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast;\n})()\n;\nvar merge_union = (function com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_merge_union(component,parent_union){\nvar default_initial_state = (function (){var and__4120__auto__ = parent_union;\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = com.fulcrologic.fulcro.components.has_initial_app_state_QMARK_(parent_union);\nif(and__4120__auto____$1){\nreturn com.fulcrologic.fulcro.components.get_initial_state.cljs$core$IFn$_invoke$arity$2(parent_union,cljs.core.PersistentArrayMap.EMPTY);\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})();\nvar to_many_QMARK_ = cljs.core.vector_QMARK_(default_initial_state);\nvar component_initial_state = (function (){var and__4120__auto__ = component;\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = com.fulcrologic.fulcro.components.has_initial_app_state_QMARK_(component);\nif(and__4120__auto____$1){\nreturn com.fulcrologic.fulcro.components.get_initial_state.cljs$core$IFn$_invoke$arity$2(component,cljs.core.PersistentArrayMap.EMPTY);\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_((function (){var and__4120__auto__ = component;\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = component_initial_state;\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 = parent_union;\nif(cljs.core.truth_(and__4120__auto____$2)){\nreturn (((!(to_many_QMARK_))) && (cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(default_initial_state,component_initial_state)));\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn (merge_fn.cljs$core$IFn$_invoke$arity$2 ? merge_fn.cljs$core$IFn$_invoke$arity$2(parent_union,component_initial_state) : merge_fn.call(null,parent_union,component_initial_state));\n} else {\nreturn null;\n}\n});\nreturn walk_ast.cljs$core$IFn$_invoke$arity$2(edn_query_language.core.query__GT_ast(com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$1(root_component)),merge_union);\n});\n/**\n * Merge an arbitrary data-tree that conforms to the shape of the given query using Fulcro's\n *   standard merge and normalization logic.\n * \n *   app - A fulcro application to merge into.\n *   query - A query, derived from components, that can be used to normalized a tree of data.\n *   data-tree - A tree of data that matches the nested shape of query.\n * \n *   The options is a map containing:\n * \n *   * `:remove-missing?` If true (default false) then anything appearing in the `query` but not the `result-tree`\n *   will be removed from `state-map`.\n * \n *   NOTE: This function assumes you are merging against the root of the tree. See\n *   `merge-component` and `merge-component!` for relative merging.\n * \n *   See also `merge*`.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_BANG_ = (function com$fulcrologic$fulcro$algorithms$merge$merge_BANG_(var_args){\nvar G__63964 = arguments.length;\nswitch (G__63964) {\ncase 3:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (app__$1,data_tree,query){\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$4(app__$1,data_tree,query,cljs.core.PersistentArrayMap.EMPTY);\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$4 = (function (app__$1,data_tree,query,options){\nvar map__63966 = com.fulcrologic.fulcro.components.any__GT_app(app__$1);\nvar map__63966__$1 = (((((!((map__63966 == null))))?(((((map__63966.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__63966.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__63966):map__63966);\nvar state_atom = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63966__$1,new cljs.core.Keyword(\"com.fulcrologic.fulcro.application\",\"state-atom\",\"com.fulcrologic.fulcro.application/state-atom\",648128366));\nif(cljs.core.truth_(state_atom)){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$variadic(state_atom,com.fulcrologic.fulcro.algorithms.merge.merge_STAR_,query,data_tree,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([options], 0));\n} else {\nreturn null;\n}\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$lang$maxFixedArity = 4;\n\n/**\n * Given a state map of the application database, a component, and a tree of component-data: normalizes\n * the tree of data and merges the component table entries into the state, returning a new state map.\n * \n * Since there is not an implied root, the component itself won't be linked into your graph (though it will\n * remain correctly linked for its own consistency).\n * \n * * `state-map` - The normalized database\n * * `component` - A component class\n * * `component-data` - A tree of data that matches the shape of the component's query.\n * * `named-parameters` - Parameters from `targeting/integrate-ident*` that will let you link the merged component into the graph.\n * Named parameters may also include `:remove-missing?`, which will remove things that are queried for but do\n * not appear in the data from the state.\n * \n * See also targeting/integrate-ident*, and merge/merge-component!\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_component = (function com$fulcrologic$fulcro$algorithms$merge$merge_component(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___64141 = arguments.length;\nvar i__4731__auto___64142 = (0);\nwhile(true){\nif((i__4731__auto___64142 < len__4730__auto___64141)){\nargs__4736__auto__.push((arguments[i__4731__auto___64142]));\n\nvar G__64143 = (i__4731__auto___64142 + (1));\ni__4731__auto___64142 = G__64143;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((3) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((3)),(0),null)):null);\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_component.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4737__auto__);\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_component.cljs$core$IFn$_invoke$arity$variadic = (function (state_map,component,component_data,named_parameters){\nif(com.fulcrologic.fulcro.components.has_ident_QMARK_(component)){\nvar options = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,named_parameters);\nvar map__63975 = options;\nvar map__63975__$1 = (((((!((map__63975 == null))))?(((((map__63975.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__63975.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__63975):map__63975);\nvar remove_missing_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__63975__$1,new cljs.core.Keyword(null,\"remove-missing?\",\"remove-missing?\",-2044119224));\nvar query = com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$2(component,state_map);\nvar marked_data = (cljs.core.truth_(remove_missing_QMARK_)?com.fulcrologic.fulcro.algorithms.merge.mark_missing(component_data,query):component_data);\nvar updated_state = com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4(state_map,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"merge\",\"com.fulcrologic.fulcro.algorithms.merge/merge\",1176000440),query], null)], null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"merge\",\"com.fulcrologic.fulcro.algorithms.merge/merge\",1176000440),marked_data], null),options);\nvar real_ident = cljs.core.get.cljs$core$IFn$_invoke$arity$2(updated_state,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"merge\",\"com.fulcrologic.fulcro.algorithms.merge/merge\",1176000440));\nvar integrate_params = cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(((function (options,map__63975,map__63975__$1,remove_missing_QMARK_,query,marked_data,updated_state,real_ident){\nreturn (function (p__63980){\nvar vec__63981 = p__63980;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63981,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__63981,(1),null);\nif(cljs.core.truth_((function (){var fexpr__63984 = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"replace\",\"replace\",-786587770),null,new cljs.core.Keyword(null,\"prepend\",\"prepend\",342616040),null,new cljs.core.Keyword(null,\"append\",\"append\",-291298229),null], null), null);\nreturn (fexpr__63984.cljs$core$IFn$_invoke$arity$1 ? fexpr__63984.cljs$core$IFn$_invoke$arity$1(k) : fexpr__63984.call(null,k));\n})())){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null);\n} else {\nreturn null;\n}\n});})(options,map__63975,map__63975__$1,remove_missing_QMARK_,query,marked_data,updated_state,real_ident))\n,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.partition.cljs$core$IFn$_invoke$arity$2((2),named_parameters)], 0));\nvar integrate_targets = ((function (options,map__63975,map__63975__$1,remove_missing_QMARK_,query,marked_data,updated_state,real_ident,integrate_params){\nreturn (function (s){\nif(cljs.core.seq(named_parameters)){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(com.fulcrologic.fulcro.algorithms.data_targeting.integrate_ident_STAR_,s,real_ident,integrate_params);\n} else {\nreturn s;\n}\n});})(options,map__63975,map__63975__$1,remove_missing_QMARK_,query,marked_data,updated_state,real_ident,integrate_params))\n;\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(integrate_targets(updated_state),new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"merge\",\"com.fulcrologic.fulcro.algorithms.merge/merge\",1176000440));\n} else {\ntaoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10(taoensso.timbre._STAR_config_STAR_,new cljs.core.Keyword(null,\"error\",\"error\",-978969032),\"com.fulcrologic.fulcro.algorithms.merge\",null,421,new cljs.core.Keyword(null,\"p\",\"p\",151049309),new cljs.core.Keyword(null,\"auto\",\"auto\",-566279492),(new cljs.core.Delay((function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"Cannot merge component \",component,\" because it does not have an ident!\"], null);\n}),null)),null,-369531964);\n\nreturn state_map;\n}\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_component.cljs$lang$maxFixedArity = (3);\n\n/** @this {Function} */\ncom.fulcrologic.fulcro.algorithms.merge.merge_component.cljs$lang$applyTo = (function (seq63971){\nvar G__63972 = cljs.core.first(seq63971);\nvar seq63971__$1 = cljs.core.next(seq63971);\nvar G__63973 = cljs.core.first(seq63971__$1);\nvar seq63971__$2 = cljs.core.next(seq63971__$1);\nvar G__63974 = cljs.core.first(seq63971__$2);\nvar seq63971__$3 = cljs.core.next(seq63971__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__63972,G__63973,G__63974,seq63971__$3);\n});\n\n/**\n * Normalize and merge a (sub)tree of application state into the application using a known UI component's query and ident.\n * \n *   This utility function obtains the ident of the incoming object-data using the UI component's ident function. Once obtained,\n *   it uses the component's query and ident to normalize the data and places the resulting objects in the correct tables.\n *   It is also quite common to want those new objects to be linked into lists in other spots in app state, so this function\n *   supports optional named parameters for doing this. These named parameters can be repeated as many times as you like in order\n *   to place the ident of the new object into other data structures of app state.\n * \n *   This function honors the data merge story for Fulcro: attributes that are queried for but do not appear in the\n *   data will be removed from the application. This function also uses the initial state for the component as a base\n *   for merge if there was no state for the object already in the database.\n * \n *   This function will also trigger re-renders of components that directly render object merged, as well as any components\n *   into which you integrate that data via the named-parameters.\n * \n *   This function is primarily meant to be used from things like server push and setTimeout/setInterval, where you're outside\n *   of the normal mutation story. Do not use this function within abstract mutations.\n * \n *   * `app`: Your application.\n *   * `component`: The class of the component that corresponds to the data. Must have an ident.\n *   * `object-data`: A map (tree) of data to merge. Will be normalized for you.\n *   * `named-parameter`: Post-processing ident integration steps. see `targeting/integrate-ident*`. You may also\n *   include `:remove-missing? true/false` to indicate that data that is missing for the component's query\n *   should be removed from app state.\n * \n *   Any keywords that appear in ident integration steps will be added to the re-render queue.\n * \n *   See also `fulcro.client.primitives/merge!`.\n *   \n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_ = (function com$fulcrologic$fulcro$algorithms$merge$merge_component_BANG_(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___64155 = arguments.length;\nvar i__4731__auto___64157 = (0);\nwhile(true){\nif((i__4731__auto___64157 < len__4730__auto___64155)){\nargs__4736__auto__.push((arguments[i__4731__auto___64157]));\n\nvar G__64160 = (i__4731__auto___64157 + (1));\ni__4731__auto___64157 = G__64160;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((3) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((3)),(0),null)):null);\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4737__auto__);\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (app__$1,component,object_data,named_parameters){\nvar temp__5753__auto__ = com.fulcrologic.fulcro.components.any__GT_app(app__$1);\nif(cljs.core.truth_(temp__5753__auto__)){\nvar app__$2 = temp__5753__auto__;\nif((!(com.fulcrologic.fulcro.components.has_ident_QMARK_(component)))){\nreturn taoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10(taoensso.timbre._STAR_config_STAR_,new cljs.core.Keyword(null,\"error\",\"error\",-978969032),\"com.fulcrologic.fulcro.algorithms.merge\",null,457,new cljs.core.Keyword(null,\"p\",\"p\",151049309),new cljs.core.Keyword(null,\"auto\",\"auto\",-566279492),(new cljs.core.Delay(((function (app__$2,temp__5753__auto__){\nreturn (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"merge-component!: component must implement Ident. Merge skipped.\"], null);\n});})(app__$2,temp__5753__auto__))\n,null)),null,-80774957);\n} else {\nvar state = new cljs.core.Keyword(\"com.fulcrologic.fulcro.application\",\"state-atom\",\"com.fulcrologic.fulcro.application/state-atom\",648128366).cljs$core$IFn$_invoke$arity$1(app__$2);\nvar render_BANG_ = com.fulcrologic.fulcro.algorithms.lookup.app_algorithm(app__$2,new cljs.core.Keyword(null,\"schedule-render!\",\"schedule-render!\",2095050350));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(state,((function (state,render_BANG_,app__$2,temp__5753__auto__){\nreturn (function (s){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(com.fulcrologic.fulcro.algorithms.merge.merge_component,s,component,object_data,named_parameters);\n});})(state,render_BANG_,app__$2,temp__5753__auto__))\n);\n\nvar G__63997 = app__$2;\nvar G__63998 = cljs.core.PersistentArrayMap.EMPTY;\nreturn (render_BANG_.cljs$core$IFn$_invoke$arity$2 ? render_BANG_.cljs$core$IFn$_invoke$arity$2(G__63997,G__63998) : render_BANG_.call(null,G__63997,G__63998));\n}\n} else {\nreturn null;\n}\n});\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_.cljs$lang$maxFixedArity = (3);\n\n/** @this {Function} */\ncom.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_.cljs$lang$applyTo = (function (seq63988){\nvar G__63989 = cljs.core.first(seq63988);\nvar seq63988__$1 = cljs.core.next(seq63988);\nvar G__63990 = cljs.core.first(seq63988__$1);\nvar seq63988__$2 = cljs.core.next(seq63988__$1);\nvar G__63991 = cljs.core.first(seq63988__$2);\nvar seq63988__$3 = cljs.core.next(seq63988__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__63989,G__63990,G__63991,seq63988__$3);\n});\n\n/**\n * Just like merge-alternate-union-elements!, but usable from within mutations and on server-side rendering. Ensures\n *   that when a component has initial state it will end up in the state map, even if it isn't currently in the\n *   initial state of the union component (which can only point to one at a time).\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_alternate_union_elements = (function com$fulcrologic$fulcro$algorithms$merge$merge_alternate_union_elements(state_map,root_component){\nvar state_map_atom = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(state_map);\nvar merge_to_state = ((function (state_map_atom){\nreturn (function (comp,tree){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(state_map_atom,com.fulcrologic.fulcro.algorithms.merge.merge_component,comp,tree);\n});})(state_map_atom))\n;\nvar _ = com.fulcrologic.fulcro.algorithms.merge.merge_alternate_unions(merge_to_state,root_component);\nvar new_state = cljs.core.deref(state_map_atom);\nreturn new_state;\n});\n/**\n * Walks the query and initial state of root-component and merges the alternate sides of unions with initial state into\n *   the application state database. See also `merge-alternate-union-elements`, which can be used on a state map and\n *   is handy for server-side rendering. This function side-effects on your app, and returns nothing.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_alternate_union_elements_BANG_ = (function com$fulcrologic$fulcro$algorithms$merge$merge_alternate_union_elements_BANG_(app__$1,root_component){\nvar app__$2 = com.fulcrologic.fulcro.components.any__GT_app(app__$1);\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_alternate_unions(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(com.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_,app__$2),root_component);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","Various algorithms that are used for merging trees of data into a normalized Fulcro database.","~:file","com/fulcrologic/fulcro/algorithms/merge.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",44],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.core","~$cljs.core","~$clojure.test","~$cljs.test","~$clojure.spec.test.alpha","~$cljs.spec.test.alpha","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha","~$clojure.pprint","~$cljs.pprint","~$clojure.core.async","~$cljs.core.async"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$com.fulcrologic.fulcro.algorithms.merge","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$ah","~$com.fulcrologic.fulcro.algorithms.lookup","~$edn-query-language.core","^X","~$com.fulcrologic.fulcro.algorithms.normalize","^Y","~$log","~$taoensso.timbre","~$targeting","~$com.fulcrologic.fulcro.algorithms.data-targeting","~$comp","~$com.fulcrologic.fulcro.components","~$eql","^X","~$com.fulcrologic.fulcro.algorithms.denormalize","^15","~$fnorm","^Y","^B","^B","~$goog","^17","^11","^11","~$util","~$com.fulcrologic.fulcro.algorithms.do-not-use","^W","^W","^13","^13","^[","^[","~$fdn","^15","^19","^19"],"~:seen",["^O",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^B","^B","^Z","^[","^12","^13","^13","^13","^[","^["],"~:form",["~#list",["~$ns","^Q","Various algorithms that are used for merging trees of data into a normalized Fulcro database.",["^1@",["^1<",["^11","~:as","^10"],["^13","^1B","^12"],["^W","^1B","^V"],["^Y","^1B","^16"],["^15","^1B","^1:"],["^19","^1B","^18"],["^X","^1B","^14"],["^[","^1B","^Z"]]]]],"~:flags",["^ ","^1<",["^O",[]]],"~:js-deps",["^ "],"~:deps",["^17","^B","^11","^13","^W","^Y","^15","^19","^X","^["]],"^S","^Q","~:resource-id",["~:shadow.build.classpath/resource","com/fulcrologic/fulcro/algorithms/merge.cljc"],"~:compiled-at",1630228424784,"~:resource-name","com/fulcrologic/fulcro/algorithms/merge.cljc","~:warnings",[],"~:source","(ns com.fulcrologic.fulcro.algorithms.merge\n  \"Various algorithms that are used for merging trees of data into a normalized Fulcro database.\"\n  (:require\n    [com.fulcrologic.fulcro.algorithms.data-targeting :as targeting]\n    [com.fulcrologic.fulcro.components :as comp]\n    [com.fulcrologic.fulcro.algorithms.lookup :as ah]\n    [com.fulcrologic.fulcro.algorithms.normalize :as fnorm]\n    [com.fulcrologic.fulcro.algorithms.denormalize :as fdn]\n    [com.fulcrologic.fulcro.algorithms.do-not-use :as util]\n    [edn-query-language.core :as eql]\n    [taoensso.timbre :as log]))\n\n(defn remove-ident*\n  \"Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations.\"\n  [state-map ident path-to-idents]\n  {:pre [(map? state-map)]}\n  (let [new-list (fn [old-list]\n                   (vec (filter #(not= ident %) old-list)))]\n    (update-in state-map path-to-idents new-list)))\n\n(defn is-ui-query-fragment?\n  \"Check the given keyword to see if it is in the :ui namespace.\"\n  [kw]\n  (let [kw (if (map? kw) (-> kw keys first) kw)]\n    (when (keyword? kw) (some->> kw namespace (re-find #\"^ui(?:\\.|$)\")))))\n\n(defn not-found?\n  \"Returns true if the `k` in `props` is the sweep-merge not-found marker. This marker appears\n  *during* merge, and can affect `:pre-merge` processing, since the data-tree will have these\n  markers when the given data is missing.\"\n  [props k]\n  (= ::not-found (get props k)))\n\n(defn nilify-not-found\n  \"Given x, return x value unless it's ::not-found (the mark/sweep missing marker), in which case it returns nil.\n\n  This is useful when you are pre-processing a tree that has been marked for missing data sweep (see `mark-missing`),\n  but has not yet been swept. This is basically the same as a `nil?` check in this circumstance since the given\n  value will be removed after the final sweep.\"\n  [x]\n  (if (= x ::not-found) nil x))\n\n(defn- as-leaf\n  \"Returns `data` with meta-data that marks it as a leaf in the result.\"\n  [data]\n  (if (coll? data)\n    (with-meta data {:fulcro/leaf true})\n    data))\n\n(defn- leaf?\n  \"Returns true iff the given data is marked as a leaf in the result (according to the query). Requires pre-marking.\"\n  [data]\n  (or\n    (not (coll? data))\n    (empty? data)\n    (and (coll? data)\n      (-> data meta :fulcro/leaf boolean))))\n\n(defn- union->query\n  \"Turn a union query into a query that attempts to encompass all possible things that might be queried.\"\n  [union-query]\n  (->> union-query vals flatten set vec))\n\n(defn mark-missing\n  \"Recursively walk the query and response marking anything that was *asked for* in the query but is *not* in the response as missing.\n  The sweep-merge process (which happens later in the plumbing) uses these markers as indicators to remove any existing\n  data in the target of the merge (i.e. your state database).\n\n  The naive approach to data merging (even recursive) would fail to remove such data.\n\n  Returns the result with missing markers in place (which are then used/removed in a later stage).\n\n  See the Developer Guide section on Fulcro's merge process for more information.\"\n  [result query]\n  (let [missing-entity ::not-found]\n    (reduce (fn [result element]\n              (let [element      (cond\n                                   (list? element) (first element)\n                                   :else element)\n                    result-key   (cond\n                                   (keyword? element) element\n                                   (util/join? element) (util/join-key element)\n                                   :else nil)\n                    result-value (get result result-key)]\n                (cond\n                  (or (and (eql/ident? result-key) (= '_ (second result-key)))\n                    (and (eql/ident? element) (= '_ (second element))))\n                  result\n\n                  (is-ui-query-fragment? result-key)\n                  result\n\n                  ; plain missing prop\n                  (and (keyword? element) (nil? (get result element)))\n                  (assoc result element ::not-found)\n\n                  ; recursion\n                  (and (util/join? element) (or (number? (util/join-value element)) (= '... (util/join-value element))))\n                  (let [k       (util/join-key element)\n                        result' (get result k)]\n                    (cond\n                      (nil? result') (assoc result k ::not-found) ; TODO: Is this right? Or, should it just be `result`?\n                      (vector? result') (assoc result k (mapv (fn [item] (mark-missing item query)) result'))\n                      :otherwise (assoc result k (mark-missing result' query))))\n\n                  ; pure ident query\n                  (and (eql/ident? element) (nil? (get result element)))\n                  (assoc result element missing-entity)\n\n                  ; union (a join with a map as a target query)\n                  (util/union? element)\n                  (let [v          (get result result-key ::not-found)\n                        to-one?    (map? v)\n                        to-many?   (vector? v)\n                        wide-query (union->query (util/join-value element))]\n                    (cond\n                      to-one? (assoc result result-key (mark-missing v wide-query))\n                      to-many? (assoc result result-key (mapv (fn [i] (mark-missing i wide-query)) v))\n                      (= ::not-found v) (assoc result result-key ::not-found)\n                      :else result))\n\n                  ; ident-based join to nothing (removing table entries)\n                  (and (util/join? element) (eql/ident? (util/join-key element)) (nil? (get result (util/join-key element))))\n                  (let [mock-missing-object (mark-missing {} (util/join-value element))]\n                    (assoc result (util/join-key element) (merge mock-missing-object missing-entity)))\n\n                  ; join to nothing\n                  (and (util/join? element) (= ::not-found (get result (util/join-key element) ::not-found)))\n                  (assoc result (util/join-key element) ::not-found)\n\n                  ; to-many join\n                  (and (util/join? element) (vector? (get result (util/join-key element))))\n                  (assoc result (util/join-key element) (mapv (fn [item] (mark-missing item (util/join-value element))) (get result (util/join-key element))))\n\n                  ; to-one join\n                  (and (util/join? element) (map? (get result (util/join-key element))))\n                  (assoc result (util/join-key element) (mark-missing (get result (util/join-key element)) (util/join-value element)))\n\n                  ; join, but with a broken result (scalar instead of a map or vector)\n                  (and (util/join? element) (vector? (util/join-value element)) (not (or (map? result-value) (vector? result-value))))\n                  (assoc result result-key (mark-missing {} (util/join-value element)))\n\n                  ; prop we found, but not a further join...mark it as a leaf so sweep can stop early on it\n                  result-key\n                  (update result result-key as-leaf)\n\n                  :else result))) result query)))\n\n(defn- sweep-one\n  \"Remove not-found keys from m (non-recursive). `m` can be a map (sweep the values) or vector (run sweep-one on each entry).\"\n  [m]\n  (cond\n    (map? m) (reduce (fn [acc [k v]]\n                       (if (or (= ::not-found k) (= ::not-found v) (= :tempids k))\n                         acc\n                         (assoc acc k v)))\n               (with-meta {} (meta m)) m)\n    (vector? m) (with-meta (mapv sweep-one m) (meta m))\n    :else m))\n\n(defn sweep\n  \"Remove all of the not-found keys (recursively) from m, stopping at marked leaves (if present). Requires `m`\n  to have been pre-marked via `mark-missing`.\"\n  [m]\n  (cond\n    (leaf? m) (sweep-one m)\n    (map? m) (reduce (fn [acc [k v]]\n                       (cond\n                         (or (= ::not-found k) (= ::not-found v) (= :tempids k)) acc\n                         (and (eql/ident? v) (= ::not-found (second v))) acc\n                         :otherwise (assoc acc k (sweep v))))\n               (with-meta {} (meta m))\n               m)\n    (vector? m) (with-meta (mapv sweep m) (meta m))\n    :else m))\n\n(defn sweep-merge\n  \"Do a recursive merge of source into target (both maps), but remove any target data that is marked as missing in the response.\n\n  Requires that the `source` has been marked via `mark-missing`.\n\n  The missing marker is generated in the source when something has been asked for in the query, but had no value in the\n  response. This allows us to correctly remove 'empty' data from the database without accidentally removing something\n  that may still exist on the server (in truth we don't know its status, since it wasn't asked for, but we leave\n  it as our 'best guess').\"\n  [target source]\n  (reduce\n    (fn [acc [key new-value]]\n      (let [existing-value (get acc key)]\n        (cond\n          (or (= key :tempids) (= key ::not-found)) acc\n          (= new-value ::not-found) (dissoc acc key)\n          (and (eql/ident? new-value) (= ::not-found (second new-value))) acc\n          (leaf? new-value) (assoc acc key (sweep-one new-value))\n          (and (map? existing-value) (map? new-value)) (update acc key sweep-merge new-value)\n          :else (assoc acc key (sweep new-value)))))\n    target\n    source))\n\n(defn- component-pre-merge [class query state data {:keys [remove-missing?]}]\n  (if (comp/has-pre-merge? class)\n    (let [entity          (some->> (comp/get-ident class data) (get-in state))\n          unmarked-data   (if remove-missing?\n                            (sweep-merge {} data)\n                            data)\n          unmarked-result (comp/pre-merge class {:state-map          state\n                                                 :current-normalized entity\n                                                 :data-tree          unmarked-data\n                                                 :query              query})\n          result          (if remove-missing?\n                            (mark-missing unmarked-result query)\n                            unmarked-result)]\n      result)\n    data))\n\n(defn pre-merge-transform\n  \"Transform function that modifies data using component pre-merge hook.\"\n  ([state]\n   (pre-merge-transform state {}))\n  ([state options]\n   (fn pre-merge-transform-internal [query data]\n     (if-let [class (-> query meta :component)]\n       (component-pre-merge class query state data options)\n       data))))\n\n(defn merge-mutation-joins\n  \"Merge all of the mutations that were joined with a query.\n\n  The options, if supplied, can include:\n\n  * `:remove-missing?`: (default false) If true then any items that appear in the `query` but not in the\n  `data-tree` will be removed from `state` (if present).\"\n  ([state query data-tree]\n   (merge-mutation-joins state query data-tree {}))\n  ([state query data-tree {:keys [remove-missing?] :as options}]\n   (if (map? data-tree)\n     (reduce (fn [updated-state query-element]\n               (let [k       (and (util/mutation-join? query-element) (util/join-key query-element))\n                     subtree (get data-tree k)]\n                 (if (and k subtree)\n                   (let [subquery         (util/join-value query-element)\n                         target           (-> (meta subquery) ::targeting/target)\n                         idnt             ::temporary-key\n                         norm-query       [{idnt subquery}]\n                         norm-tree        {idnt subtree}\n                         norm-tree-marked (if remove-missing?\n                                            (mark-missing norm-tree norm-query)\n                                            norm-tree)\n                         db               (fnorm/tree->db norm-query norm-tree-marked true (pre-merge-transform state options))]\n                     (cond-> (sweep-merge updated-state db)\n                       target (targeting/process-target idnt target)\n                       (not target) (dissoc db idnt)))\n                   updated-state))) state query)\n     state)))\n\n(defn merge-ident [app-state ident props]\n  (update-in app-state ident (comp sweep-one merge) props))\n\n(defn- sift-idents [res]\n  (let [{idents true rest false} (group-by #(vector? (first %)) res)]\n    [(into {} idents) (into {} rest)]))\n\n(defn merge-tree\n  \"Handle merging incoming data and sweep it of values that are marked missing. This function also ensures that raw\n   mutation join results are ignored (they must be merged via `merge-mutation-joins`).\"\n  [target source]\n  (let [source-to-merge (into {}\n                          (filter (fn [[k _]] (not (symbol? k))))\n                          source)]\n    (sweep-merge target source-to-merge)))\n\n(defn merge-idents\n  \"Merge the given `refs` (a map from ident to props), query (a query that contains ident-joins), and tree:\n\n  returns a new tree with the data merged into the proper ident-based tables.\"\n  [tree query refs {:keys [remove-missing?] :as options}]\n  (let [ident-joins (into {} (comp\n                               (map #(cond-> % (seq? %) first))\n                               (filter #(and (util/join? %)\n                                          (eql/ident? (util/join-key %)))))\n                      query)]\n    (letfn [(step [result-tree [ident props]]\n              (let [component-query (get ident-joins ident '[*])\n                    marked-props    (if remove-missing?\n                                      (mark-missing props component-query)\n                                      props)\n                    normalized-data (fnorm/tree->db component-query marked-props false (pre-merge-transform tree options))\n                    refs            (meta normalized-data)]\n                (merge-tree (merge-ident result-tree ident normalized-data) refs)))]\n      (reduce step tree refs))))\n\n(defn merge*\n  \"Merge the query-result of a query using Fulcro's standard merge and normalization logic.\n\n  Typically used on the state atom as:\n\n  ```\n  (swap! state merge* query-result query)\n  ```\n\n  - `state-map` - The normalized database.\n  - `query` - The query that was used to obtain the query-result. This query will be treated relative to the root of the database.\n  - `tree` - The query-result to merge (a map).\n\n  The options is a map containing:\n\n  * `:remove-missing?` If true (default false) then anything appearing in the `query` but not the `result-tree`\n  will be removed from `state-map`.\n\n  See `merge-component` and `merge-component!` for possibly more appropriate functions for your task.\n\n  Returns the new normalized database.\"\n  ([state-map query result-tree] (merge* state-map query result-tree {}))\n  ([state-map query result-tree {:keys [remove-missing?] :as options}]\n   (let [[idts result-tree] (sift-idents result-tree)\n         normalized-result (fnorm/tree->db query result-tree true (pre-merge-transform state-map options))]\n     (-> state-map\n       (merge-mutation-joins query result-tree options)\n       (merge-idents query idts options)\n       (merge-tree normalized-result)))))\n\n(defn component-merge-query\n  \"Calculates the query that can be used to pull (or merge) a component with an ident\n  to/from a normalized app database. Requires a tree of data that represents the instance of\n  the component in question (e.g. ident will work on it)\"\n  [state-map component object-data]\n  (let [ident        (comp/ident component object-data)\n        object-query (comp/get-query component state-map)]\n    [{ident object-query}]))\n\n(defn merge-alternate-unions\n  \"Walks the given query and calls (merge-fn parent-union-component union-child-initial-state) for each non-default element of a union that has initial app state.\n  You probably want to use merge-alternate-union-elements[!] on a state map or app.\"\n  [merge-fn root-component]\n  (letfn [(walk-ast\n            ([ast visitor]\n             (walk-ast ast visitor nil))\n            ([{:keys [children component type dispatch-key union-key key] :as parent-ast} visitor parent-union]\n             (when (and component parent-union (= :union-entry type))\n               (visitor component parent-union))\n             (when children\n               (doseq [ast children]\n                 (cond\n                   (= (:type ast) :union) (walk-ast ast visitor component) ; the union's component is on the parent join\n                   (= (:type ast) :union-entry) (walk-ast ast visitor parent-union)\n                   ast (walk-ast ast visitor nil))))))\n          (merge-union [component parent-union]\n            (let [default-initial-state   (and parent-union (comp/has-initial-app-state? parent-union) (comp/get-initial-state parent-union {}))\n                  to-many?                (vector? default-initial-state)\n                  component-initial-state (and component (comp/has-initial-app-state? component) (comp/get-initial-state component {}))]\n              (when (and component component-initial-state parent-union (not to-many?) (not= default-initial-state component-initial-state))\n                (merge-fn parent-union component-initial-state))))]\n    (walk-ast\n      (eql/query->ast (comp/get-query root-component))\n      merge-union)))\n\n(defn merge!\n  \"Merge an arbitrary data-tree that conforms to the shape of the given query using Fulcro's\n  standard merge and normalization logic.\n\n  app - A fulcro application to merge into.\n  query - A query, derived from components, that can be used to normalized a tree of data.\n  data-tree - A tree of data that matches the nested shape of query.\n\n  The options is a map containing:\n\n  * `:remove-missing?` If true (default false) then anything appearing in the `query` but not the `result-tree`\n  will be removed from `state-map`.\n\n  NOTE: This function assumes you are merging against the root of the tree. See\n  `merge-component` and `merge-component!` for relative merging.\n\n  See also `merge*`.\"\n\n  ([app data-tree query]\n   (merge! app data-tree query {}))\n  ([app data-tree query options]\n   (let [{:com.fulcrologic.fulcro.application/keys [state-atom]} (comp/any->app app)]\n     (when state-atom\n       (swap! state-atom merge* query data-tree options)))))\n\n(defn merge-component\n  \"Given a state map of the application database, a component, and a tree of component-data: normalizes\n   the tree of data and merges the component table entries into the state, returning a new state map.\n\n   Since there is not an implied root, the component itself won't be linked into your graph (though it will\n   remain correctly linked for its own consistency).\n\n   * `state-map` - The normalized database\n   * `component` - A component class\n   * `component-data` - A tree of data that matches the shape of the component's query.\n   * `named-parameters` - Parameters from `targeting/integrate-ident*` that will let you link the merged component into the graph.\n   Named parameters may also include `:remove-missing?`, which will remove things that are queried for but do\n   not appear in the data from the state.\n\n   See also targeting/integrate-ident*, and merge/merge-component!\"\n  [state-map component component-data & named-parameters]\n  (if (comp/has-ident? component)\n    (let [options           (apply hash-map named-parameters)\n          {:keys [remove-missing?]} options\n          query             (comp/get-query component state-map)\n          marked-data       (if remove-missing?\n                              (mark-missing component-data query)\n                              component-data)\n          updated-state     (merge* state-map [{::merge query}] {::merge marked-data} options)\n          real-ident        (get updated-state ::merge)\n          integrate-params  (mapcat (fn [[k v]]\n                                      (if (#{:append :prepend :replace} k)\n                                        [k v]\n                                        nil))\n                              (partition 2 named-parameters))\n          integrate-targets (fn [s]\n                              (if (seq named-parameters)\n                                (apply targeting/integrate-ident* s real-ident integrate-params)\n                                s))]\n      (-> updated-state\n        (integrate-targets)\n        (dissoc ::merge)))\n    (do\n      (log/error \"Cannot merge component \" component \" because it does not have an ident!\")\n      state-map)))\n\n(defn merge-component!\n  \"Normalize and merge a (sub)tree of application state into the application using a known UI component's query and ident.\n\n  This utility function obtains the ident of the incoming object-data using the UI component's ident function. Once obtained,\n  it uses the component's query and ident to normalize the data and places the resulting objects in the correct tables.\n  It is also quite common to want those new objects to be linked into lists in other spots in app state, so this function\n  supports optional named parameters for doing this. These named parameters can be repeated as many times as you like in order\n  to place the ident of the new object into other data structures of app state.\n\n  This function honors the data merge story for Fulcro: attributes that are queried for but do not appear in the\n  data will be removed from the application. This function also uses the initial state for the component as a base\n  for merge if there was no state for the object already in the database.\n\n  This function will also trigger re-renders of components that directly render object merged, as well as any components\n  into which you integrate that data via the named-parameters.\n\n  This function is primarily meant to be used from things like server push and setTimeout/setInterval, where you're outside\n  of the normal mutation story. Do not use this function within abstract mutations.\n\n  * `app`: Your application.\n  * `component`: The class of the component that corresponds to the data. Must have an ident.\n  * `object-data`: A map (tree) of data to merge. Will be normalized for you.\n  * `named-parameter`: Post-processing ident integration steps. see `targeting/integrate-ident*`. You may also\n  include `:remove-missing? true/false` to indicate that data that is missing for the component's query\n  should be removed from app state.\n\n  Any keywords that appear in ident integration steps will be added to the re-render queue.\n\n  See also `fulcro.client.primitives/merge!`.\n  \"\n  [app component object-data & named-parameters]\n  (when-let [app (comp/any->app app)]\n    (if-not (comp/has-ident? component)\n      (log/error \"merge-component!: component must implement Ident. Merge skipped.\")\n      (let [state   (:com.fulcrologic.fulcro.application/state-atom app)\n            render! (ah/app-algorithm app :schedule-render!)]\n        (swap! state (fn [s] (apply merge-component s component object-data named-parameters)))\n        (render! app {})))))\n\n(defn merge-alternate-union-elements\n  \"Just like merge-alternate-union-elements!, but usable from within mutations and on server-side rendering. Ensures\n  that when a component has initial state it will end up in the state map, even if it isn't currently in the\n  initial state of the union component (which can only point to one at a time).\"\n  [state-map root-component]\n  (let [state-map-atom (atom state-map)\n        merge-to-state (fn [comp tree] (swap! state-map-atom merge-component comp tree))\n        _              (merge-alternate-unions merge-to-state root-component)\n        new-state      @state-map-atom]\n    new-state))\n\n(defn merge-alternate-union-elements!\n  \"Walks the query and initial state of root-component and merges the alternate sides of unions with initial state into\n  the application state database. See also `merge-alternate-union-elements`, which can be used on a state map and\n  is handy for server-side rendering. This function side-effects on your app, and returns nothing.\"\n  [app root-component]\n  (let [app (comp/any->app app)]\n    (merge-alternate-unions (partial merge-component! app) root-component)))\n\n","~:reader-features",["^O",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["js/Error","com.fulcrologic.fulcro.algorithms.merge/remove-ident*","state-map","ident","path-to-idents","cljs.core/map?","new-list","old-list","cljs.core/vec","p1__63801#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.algorithms.merge/is-ui-query-fragment?","kw","cljs.core/keys","cljs.core/first","cljs.core/Keyword","G__63805","cljs.core/namespace","cljs.core/re-find","com.fulcrologic.fulcro.algorithms.merge/not-found?","props","k","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.get.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.algorithms.merge/nilify-not-found","x","com.fulcrologic.fulcro.algorithms.merge/as-leaf","data","cljs.core/coll?","cljs.core/with-meta","com.fulcrologic.fulcro.algorithms.merge/leaf?","cljs.core/empty?","cljs.core/meta","cljs.core/boolean","com.fulcrologic.fulcro.algorithms.merge/union->query","union-query","cljs.core/vals","cljs.core/flatten","cljs.core/set","com.fulcrologic.fulcro.algorithms.merge/mark-missing","result","query","missing-entity","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","element","cljs.core/list?","result-key","com.fulcrologic.fulcro.algorithms.do-not-use/join?","com.fulcrologic.fulcro.algorithms.do-not-use/join-key","result-value","edn-query-language.core/ident?","cljs.core/second","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.algorithms.do-not-use/join-value","result'","cljs.core/vector?","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","item","com.fulcrologic.fulcro.algorithms.do-not-use/union?","v","cljs.core.get.cljs$core$IFn$_invoke$arity$3","to-one?","to-many?","wide-query","i","mock-missing-object","G__63824","G__63825","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","G__63827","G__63828","G__63829","G__63830","G__63834","G__63835","cljs.core.update.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.algorithms.merge/sweep-one","m","p__63836","vec__63839","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","acc","com.fulcrologic.fulcro.algorithms.merge/sweep","p__63843","vec__63844","com.fulcrologic.fulcro.algorithms.merge/sweep-merge","target","source","p__63850","vec__63851","key","new-value","existing-value","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","cljs.core.update.cljs$core$IFn$_invoke$arity$4","p__63857","map__63858","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","com.fulcrologic.fulcro.algorithms.merge/component-pre-merge","class","state","remove-missing?","com.fulcrologic.fulcro.components/has-pre-merge?","entity","G__63863","com.fulcrologic.fulcro.components.get_ident.cljs$core$IFn$_invoke$arity$2","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","unmarked-data","unmarked-result","com.fulcrologic.fulcro.components/pre-merge","var_args","G__63865","com.fulcrologic.fulcro.algorithms.merge/pre-merge-transform","com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2","options","temp__5751__auto__","G__63873","com.fulcrologic.fulcro.algorithms.merge/merge-mutation-joins","p__63874","map__63875","data-tree","com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4","updated-state","query-element","and__4120__auto__","com.fulcrologic.fulcro.algorithms.do-not-use/mutation-join?","subtree","subquery","idnt","norm-query","norm-tree","norm-tree-marked","db","com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db.cljs$core$IFn$_invoke$arity$4","G__63880","com.fulcrologic.fulcro.algorithms.data_targeting.process_target.cljs$core$IFn$_invoke$arity$3","cljs.core/not","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic","com.fulcrologic.fulcro.algorithms.merge/merge-ident","app-state","cljs.core.update_in.cljs$core$IFn$_invoke$arity$4","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cljs.core/merge","com.fulcrologic.fulcro.algorithms.merge/sift-idents","res","map__63885","idents","rest","p1__63884#","cljs.core/group-by","cljs.core.into.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.algorithms.merge/merge-tree","source-to-merge","cljs.core.into.cljs$core$IFn$_invoke$arity$3","cljs.core.filter.cljs$core$IFn$_invoke$arity$1","p__63890","vec__63891","_","cljs.core/Symbol","p__63896","map__63897","com.fulcrologic.fulcro.algorithms.merge/merge-idents","tree","refs","ident-joins","p1__63894#","cljs.core.map.cljs$core$IFn$_invoke$arity$1","G__63902","cljs.core/seq?","p1__63895#","p__63909","vec__63911","result-tree","component-query","marked-props","normalized-data","step","G__63915","com.fulcrologic.fulcro.algorithms.merge/merge*","p__63920","map__63921","com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4","vec__63923","idts","normalized-result","com.fulcrologic.fulcro.algorithms.merge/component-merge-query","component","object-data","com.fulcrologic.fulcro.components/ident","object-query","com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.algorithms.merge/merge-alternate-unions","merge-fn","root-component","p__63945","map__63946","ast","visitor","com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3","children","type","dispatch-key","union-key","parent-ast","parent-union","seq__63951","cljs.core/seq","chunk__63952","count__63953","i__63954","temp__5753__auto__","cljs.core/chunked-seq?","c__4550__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/next","default-initial-state","com.fulcrologic.fulcro.components/has-initial-app-state?","com.fulcrologic.fulcro.components.get_initial_state.cljs$core$IFn$_invoke$arity$2","component-initial-state","walk_ast.cljs$core$IFn$_invoke$arity$2","edn-query-language.core/query->ast","com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$1","merge-union","G__63964","com.fulcrologic.fulcro.algorithms.merge/merge!","app","com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$4","map__63966","state-atom","com.fulcrologic.fulcro.components/any->app","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$variadic","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.merge/merge-component","seq63971","G__63972","G__63973","G__63974","self__4717__auto__","component-data","named-parameters","com.fulcrologic.fulcro.components/has-ident?","map__63975","marked-data","real-ident","integrate-params","cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic","p__63980","vec__63981","fexpr__63984","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","integrate-targets","s","cljs.core.apply.cljs$core$IFn$_invoke$arity$4","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","taoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10","taoensso.timbre/*config*","cljs.core/Delay","com.fulcrologic.fulcro.algorithms.merge/merge-component!","seq63988","G__63989","G__63990","G__63991","render!","com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2","cljs.core.apply.cljs$core$IFn$_invoke$arity$5","G__63997","G__63998","com.fulcrologic.fulcro.algorithms.merge/merge-alternate-union-elements","cljs.core/deref","state-map-atom","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","merge-to-state","comp","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4","new-state","com.fulcrologic.fulcro.algorithms.merge/merge-alternate-union-elements!","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]]],"~:cache-keys",["~#cmap",[["^1G","ghostwheel/utils.cljc"],[1630228119207,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^O",[]],"~:deps-syms",["^17","^B","~$clojure.walk","~$cljs.env","~$orchestra-cljs.spec.test"]]],["^1G","com/fulcrologic/fulcro/algorithms/normalize.cljc"],[1630228119420,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^19","^X","^[","^13"]]],["^1G","goog/dom/tagname.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.dom.HtmlElement"]]],["^1G","goog/async/freelist.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/labs/useragent/platform.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.labs.userAgent.util","~$goog.string"]]],["^1G","expound/util.cljc"],[1630228118972,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","ghostwheel/reporting.cljc"],[1630228119207,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^@","^F","^D","~$expound.alpha","~$clojure.string","~$ghostwheel.logging"]]],["^1G","goog/timer/timer.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.Promise","~$goog.events.EventTarget"]]],["^1G","orchestra_cljs/spec/test.cljs"],[1630228119080,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$goog.object","~$goog.userAgent.product","^23","~$cljs.stacktrace","^J","^@","^H"]]],["^1G","com/fulcrologic/fulcro/algorithms/lookup.cljc"],[1630228119420,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^["]]],["^1G","cljs/spec/gen/alpha.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$goog.Uri"]]],["^1G","cljs/tools/reader/impl/utils.cljs"],[1630228358603,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","^21"]]],["^1G","goog/math/math.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.array","~$goog.asserts"]]],["^1G","goog/string/stringformat.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^21"]]],["^1G","cljs/env.cljc"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","goog/events/eventtype.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.events.BrowserFeature","~$goog.userAgent"]]],["^1G","goog/labs/useragent/browser.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","^20","^27","~$goog.string.internal"]]],["^1G","goog/array/array.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2<"]]],["~:shadow.build.npm/resource","node_modules/prop-types/checkPropTypes.js"],[1630228360000,1630228360000,1549836454000,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["~$shadow.js","~$module$node_modules$prop_types$lib$ReactPropTypesSecret"]]],["^1G","com/fulcrologic/fulcro/algorithms/do_not_use.cljc"],[1630228119420,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^[","^X","^27","^@"]]],["^1G","expound/problems.cljc"],[1630228118972,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$expound.paths","^@","^1X","^23","~$expound.printer","~$expound.ansi"]]],["^1G","goog/useragent/useragent.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.labs.userAgent.browser","~$goog.labs.userAgent.engine","~$goog.labs.userAgent.platform","^20","~$goog.reflect","^21"]]],["^1G","goog/structs/prioritypool.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.structs.Pool","~$goog.structs.PriorityQueue"]]],["^1G","clojure/test/check/properties.cljc"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$clojure.test.check.generators","~$clojure.test.check.results"]]],["^1G","goog/async/run.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.async.WorkQueue","~$goog.async.nextTick","~$goog.async.throwException"]]],["^1G","clojure/test/check/generators.cljc"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","~$clojure.test.check.random","~$clojure.test.check.rose-tree","^21"]]],["^1G","taoensso/encore.cljs"],[1630228119299,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","~$clojure.set","~$cljs.reader","~$cljs.tools.reader.edn","^27","^21","~$goog.string.format","~$goog.string.StringBuffer","~$goog.events","~$goog.net.XhrIo","~$goog.net.XhrIoPool","~$goog.Uri.QueryData","~$goog.structs","~$goog.net.EventType","~$goog.net.ErrorCode","~$taoensso.truss"]]],["^1G","goog/debug/error.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/async/workqueue.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2<","~$goog.async.FreeList"]]],["^1G","goog/events/events.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2<","~$goog.debug.entryPointRegistry","~$goog.events.BrowserEvent","^2=","~$goog.events.Listenable","~$goog.events.ListenerMap"]]],["^1G","goog/promise/resolver.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/events/browserfeature.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2>"]]],["^1G","cljs/tools/reader/edn.cljs"],[1630228358603,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$cljs.tools.reader.impl.errors","~$cljs.tools.reader.reader-types","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^21","^2W"]]],["^1G","clojure/test/check/random/doubles.cljs"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$clojure.test.check.random.longs"]]],["^1G","goog/structs/priorityqueue.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.structs.Heap"]]],["^1G","goog/net/xhrio.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.Timer","^2;","^2<","^35","^26","~$goog.json.hybrid","~$goog.log","^32","^31","~$goog.net.HttpStatus","~$goog.net.XmlHttp","^27","^21","^30","~$goog.structs.Map","~$goog.uri.utils","^2>"]]],["^1G","goog/promise/thenable.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/dom/nodetype.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","cljs/tools/reader/impl/inspect.cljs"],[1630228358603,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","cljs/pprint.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","^21","^2W"]]],["^1G","com/fulcrologic/fulcro/algorithms/data_targeting.cljc"],[1630228119420,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^@","^2S","~$ghostwheel.core","^[","^X"]]],["^1G","cljs/tools/reader.cljs"],[1630228358603,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^3:","^3;","^3<","^39","^2;","^21","^2W"]]],["^1G","expound/alpha.cljc"],[1630228118972,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$expound.problems","^@","^23","^2S","^1X","^2V","^21","^2D","~$expound.util","^2E","^H"]]],["^1G","clojure/test/check/rose_tree.cljc"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","clojure/test/check/impl.cljc"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","goog/net/wrapperxmlhttpfactory.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.net.XhrLike","~$goog.net.XmlHttpFactory"]]],["^1G","goog/events/eventtarget.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.Disposable","^2<","^2X","~$goog.events.Event","^37","^38","^27"]]],["^1G","clojure/test/check/random.cljs"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$clojure.test.check.random.doubles","^3>"]]],["^1G","goog/disposable/disposable.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.disposable.IDisposable"]]],["^1G","expound/ansi.cljc"],[1630228118972,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23"]]],["^2@","node_modules/react/index.js"],[1630228360000,1630228360000,499162500000,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^2A","~$module$node_modules$react$cjs$react_production_min","~$module$node_modules$react$cjs$react_development"]]],["^1G","cljs/spec/test/alpha.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^27","^28","^23","^29","^J","^@","^H"]]],["^1G","shadow/js.js"],[1630228360071,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/object/object.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/structs/set.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^30","~$goog.structs.Collection","^3E"]]],"~:SHADOW-TIMESTAMP",[1630228360000,1630228118000],["^2@","node_modules/react/cjs/react.development.js"],[1630228360000,1630228360000,499162500000,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^2A","~$module$node_modules$object_assign$index","~$module$node_modules$prop_types$checkPropTypes"]]],["^1G","cljs/stacktrace.cljc"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^21","^23"]]],["^1G","goog/math/long.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2<","^2I"]]],["^1G","goog/events/listener.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.events.ListenableKey"]]],["^1G","goog/events/listenermap.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","~$goog.events.Listener","^27"]]],["^1G","goog/events/eventid.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","taoensso/truss.cljs"],[1630228118689,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$taoensso.truss.impl"]]],["^1G","goog/string/internal.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","com/fulcrologic/fulcro/algorithms/merge.cljc"],[1630228119420,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^11","^13","^W","^Y","^15","^19","^X","^["]]],["^1G","clojure/test/check.cljc"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^2L","^2Q","^2M","^2R","~$clojure.test.check.impl"]]],["^1G","edn_query_language/core.cljc"],[1630228119293,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^@","~$clojure.test.check","^2L","~$clojure.test.check.properties"]]],["^1G","goog/functions/functions.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","expound/paths.cljc"],[1630228118972,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^@","^3I"]]],["^1G","taoensso/truss/impl.cljs"],[1630228118689,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^2S"]]],["^1G","clojure/walk.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","goog/useragent/product.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2F","^2H","^2>"]]],["^1G","goog/net/eventtype.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/structs/map.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1G","goog/net/xhriopool.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2Y","~$goog.structs.PriorityPool"]]],["^1G","goog/structs/queue.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;"]]],["^1G","goog/labs/useragent/engine.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","^20","^21"]]],["^1G","taoensso/timbre/appenders/core.cljs"],[1630228119105,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","~$taoensso.encore"]]],["^1G","cljs/reader.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^27","^3=","^2U","^2W"]]],["^1G","com/fulcrologic/fulcro/components.cljc"],[1630228119420,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^27","~$cljsjs.react","^X","^@","^[","^1X","^23","^19","^15","^W","^2S"]]],["^1G","goog/asserts/asserts.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1G","goog/debug/logbuffer.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2<","~$goog.debug.LogRecord"]]],["^1G","cljs/tagged_literals.cljc"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^2T"]]],["^1G","goog/uri/uri.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","^2<","^21","^30","^3E","^3F","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1G","ghostwheel/threading_macros.cljc"],[1630228119207,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^24","~$ghostwheel.utils"]]],["^1G","goog/net/errorcode.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^2@","node_modules/object-assign/index.js"],[1630228360000,1630228360000,1484580833000,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^2A"]]],["^1G","ghostwheel/logging.cljc"],[1630228119285,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","^J"]]],["^1G","goog/disposable/idisposable.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/promise/promise.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","~$goog.Thenable","^2<","^34","~$goog.async.run","^2P","^45","~$goog.promise.Resolver"]]],["^1G","cljs/spec/alpha.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^27","^1X","^H","^23"]]],["^1G","goog/debug/logrecord.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/base.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",[]]],["^1G","goog/json/hybrid.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2<","~$goog.json"]]],["^1G","goog/structs/structs.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","^27"]]],["^1G","cljs/tools/reader/impl/errors.cljs"],[1630228358603,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^3:","^23","~$cljs.tools.reader.impl.inspect"]]],["^1G","cljsjs/react.cljs"],[1630228358937,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$module$node_modules$react$index"]]],["^1G","clojure/string.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^21","^2W"]]],["^1G","goog/structs/pool.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^3L","~$goog.structs.Queue","~$goog.structs.Set"]]],["^1G","clojure/test/check/random/longs/bit_count_impl.cljs"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^2@","node_modules/react/cjs/react.production.min.js"],[1630228360000,1630228360000,499162500000,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^2A","^3T"]]],["^1G","goog/net/httpstatus.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/structs/heap.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","^27","~$goog.structs.Node"]]],["^1G","goog/debug/entrypointregistry.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2<"]]],["^1G","goog/string/string.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2?"]]],["^1G","goog/reflect/reflect.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/labs/useragent/util.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2?"]]],["^1G","expound/printer.cljc"],[1630228118972,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","^@","^J","^1X","^2S","^3I","^2E"]]],["^1G","goog/debug/debug.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","~$goog.debug.errorcontext","^2>"]]],["^1G","goog/string/stringbuffer.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/debug/errorcontext.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","cljs/tools/reader/reader_types.cljs"],[1630228358603,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^3;","^21","^2W"]]],["^1G","goog/iter/iter.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","^2<","~$goog.functions","~$goog.math"]]],["^1G","goog/async/nexttick.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^35","~$goog.dom.TagName","^4E","^2F","^2G"]]],["^1G","goog/debug/logger.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","^2<","~$goog.debug","~$goog.debug.LogBuffer","^47"]]],["^1G","ghostwheel/core.cljc"],[1630228119207,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","^2S","^1X","^D","^3Z","^2L","^3[","^@","^F","^H","~$ghostwheel.reporting","~$ghostwheel.unghost","^4:","^24","~$ghostwheel.threading-macros","^22","~$cljs.analyzer.api","^1Z"]]],["^2@","node_modules/prop-types/lib/ReactPropTypesSecret.js"],[1630228360000,1630228360000,1549571078000,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^2A"]]],["^1G","goog/events/event.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^3L","~$goog.events.EventId"]]],["^1G","cljs/tools/reader/impl/commons.cljs"],[1630228358603,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^39","^3:","^3;"]]],["^1G","goog/dom/htmlelement.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","cljs/core.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["~$goog.math.Long","~$goog.math.Integer","^21","^27","^2;","^2:","^2W"]]],["^1G","clojure/test/check/random/longs.cljs"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","~$clojure.test.check.random.longs.bit-count-impl","^4O","^B"]]],["^1G","goog/log/log.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^4H","~$goog.debug.LogManager","^47","~$goog.debug.Logger"]]],["^1G","goog/structs/collection.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/events/browserevent.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^4H","^2=","^3M","~$goog.events.EventType","^2I","^2>"]]],["^1G","cljs/analyzer/api.cljc"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^1Y","~$cljs.analyzer"]]],["^1G","goog/math/integer.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/structs/node.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","clojure/set.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","goog/uri/utils.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2;","^2<","^21"]]],["^1G","taoensso/timbre.cljs"],[1630228119105,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","^43","~$taoensso.timbre.appenders.core"]]],["^1G","cljs/analyzer.cljc"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^21","^23","^2S","^1Y","~$cljs.tagged-literals","^3=","^3:","^2T"]]],["^1G","goog/json/json.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]],["^1G","goog/events/listenable.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^4N"]]],["^1G","goog/net/xmlhttpfactory.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^3J"]]],["^1G","com/fulcrologic/fulcro/algorithms/denormalize.cljc"],[1630228119420,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^X"]]],["^1G","ghostwheel/unghost.cljc"],[1630228119555,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","goog/net/xmlhttp.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^2<","~$goog.net.WrapperXmlHttpFactory","^3K"]]],["^1G","cljs/test.cljs"],[1630228118934,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B","^23","^J"]]],["^1G","clojure/test/check/results.cljc"],[1630228119162,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17","^B"]]],["^1G","goog/net/xhrlike.js"],[1630228359392,"^1T",["^ ","^1U",null,"^1V",["^O",[]],"^1W",["^17"]]]]],"~:clj-info",["^ ","jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/edn.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/com/fulcrologic/fulcro/3.0.0-beta-13/fulcro-3.0.0-beta-13.jar!/com/fulcrologic/fulcro/algorithms/lookup.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/walk.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/gnl/ghostwheel.logging/0.3.9/ghostwheel.logging-0.3.9.jar!/ghostwheel/logging.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/main.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/string.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/analyzer.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/com/taoensso/timbre/4.10.0/timbre-4.10.0.jar!/taoensso/timbre/appenders/core.clj",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/util.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/externs.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/gnl/ghostwheel/0.3.9/ghostwheel-0.3.9.jar!/ghostwheel/threading_macros.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/expound/expound/0.7.2/expound-0.7.2.jar!/expound/util.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/spec.alpha/0.2.194/spec.alpha-0.2.194.jar!/clojure/spec/test/alpha.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/io/aviso/pretty/0.1.33/pretty-0.1.33.jar!/io/aviso/ansi.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/test.check/0.10.0-alpha4/test.check-0.10.0-alpha4.jar!/clojure/test/check/random.clj",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/gnl/ghostwheel/0.3.9/ghostwheel-0.3.9.jar!/ghostwheel/reporting.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/orchestra/orchestra/2019.02.06-1/orchestra-2019.02.06-1.jar!/orchestra/spec/test.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/compiler.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/default_data_readers.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map/base64_vlq.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/expound/expound/0.7.2/expound-0.7.2.jar!/expound/printer.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/cljs/tools/reader/reader_types.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/core.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/test.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/expound/expound/0.7.2/expound-0.7.2.jar!/expound/paths.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/env.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/analyzer/api.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/io/aviso/pretty/0.1.33/pretty-0.1.33.jar!/io/aviso/columns.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/core.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/spec/gen/alpha.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/com/fulcrologic/fulcro/3.0.0-beta-13/fulcro-3.0.0-beta-13.jar!/com/fulcrologic/fulcro/components.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/expound/expound/0.7.2/expound-0.7.2.jar!/expound/ansi.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/spec/alpha.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/com/taoensso/truss/1.5.0/truss-1.5.0.jar!/taoensso/truss/impl.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/js_deps.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/com/taoensso/timbre/4.10.0/timbre-4.10.0.jar!/taoensso/timbre.clj",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/test.check/0.10.0-alpha4/test.check-0.10.0-alpha4.jar!/clojure/test/check/generators.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/instant.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/set.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/gnl/ghostwheel/0.3.9/ghostwheel-0.3.9.jar!/ghostwheel/core.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/expound/expound/0.7.2/expound-0.7.2.jar!/expound/alpha.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/template.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/io/aviso/pretty/0.1.33/pretty-0.1.33.jar!/io/aviso/writer.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/data.json/0.2.6/data.json-0.2.6.jar!/clojure/data/json.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/spec.alpha/0.2.194/spec.alpha-0.2.194.jar!/clojure/spec/alpha.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/inspect.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/pprint.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/analyzer/macros.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/expound/expound/0.7.2/expound-0.7.2.jar!/expound/problems.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/io/aviso/pretty/0.1.33/pretty-0.1.33.jar!/io/aviso/exception.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/errors.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/com/fulcrologic/fulcro/3.0.0-beta-13/fulcro-3.0.0-beta-13.jar!/com/fulcrologic/fulcro/algorithms/do_not_use.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/edn-query-language/eql/0.0.7/eql-0.0.7.jar!/edn_query_language/core.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/test.check/0.10.0-alpha4/test.check-0.10.0-alpha4.jar!/clojure/test/check/results.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/java/io.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/env/macros.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/test.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/spec.alpha/0.2.194/spec.alpha-0.2.194.jar!/clojure/spec/gen/alpha.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/reader.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/gnl/ghostwheel/0.3.9/ghostwheel-0.3.9.jar!/ghostwheel/utils.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/test.check/0.10.0-alpha4/test.check-0.10.0-alpha4.jar!/clojure/test/check/properties.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/com/taoensso/truss/1.5.0/truss-1.5.0.jar!/taoensso/truss.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/test.check/0.10.0-alpha4/test.check-0.10.0-alpha4.jar!/clojure/test/check/rose_tree.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/pprint.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/stacktrace.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/orchestra/orchestra/2019.02.06-1/orchestra-2019.02.06-1.jar!/orchestra_cljs/spec/test.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/binaryage/devtools/0.9.10/devtools-0.9.10.jar!/devtools/defaults.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/com/taoensso/encore/2.94.0/encore-2.94.0.jar!/taoensso/encore.clj",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/edn.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/spec/test/alpha.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/reader_types.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/tagged_literals.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map/base64.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/com/fulcrologic/fulcro/3.0.0-beta-13/fulcro-3.0.0-beta-13.jar!/com/fulcrologic/fulcro/algorithms/denormalize.cljc",1630228119000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Various algorithms that are used for merging trees of data into a normalized Fulcro database.","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",1,"^9",5,"^:",1,"^;",44],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K","^L"],"^M",null,"^N",["^O",[]],"^P","^Q","^T",null,"^U",["^ ","^V","^W","^X","^X","^Y","^Y","^Z","^[","^10","^11","^12","^13","^14","^X","^15","^15","^16","^Y","^B","^B","^17","^17","^11","^11","^18","^19","^W","^W","^13","^13","^[","^[","^1:","^15","^19","^19"],"^1;",["^O",["^1<"]],"~:shadow/js-access-global",["^O",["Error"]],"^1=",null,"~:defs",["^ ","~$merge*",["^ ","~:protocol-inline",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",293,"^9",7,"^:",293,"^;",13,"~:arglists",["^1@",["~$quote",["^1@",[["~$state-map","~$query","~$result-tree"],["^6U","^6V","^6W",["^ ","~:keys",["~$remove-missing?"],"^1B","~$options"]]]]]],"^6","Merge the query-result of a query using Fulcro's standard merge and normalization logic.\n\n  Typically used on the state atom as:\n\n  ```\n  (swap! state merge* query-result query)\n  ```\n\n  - `state-map` - The normalized database.\n  - `query` - The query that was used to obtain the query-result. This query will be treated relative to the root of the database.\n  - `tree` - The query-result to merge (a map).\n\n  The options is a map containing:\n\n  * `:remove-missing?` If true (default false) then anything appearing in the `query` but not the `result-tree`\n  will be removed from `state-map`.\n\n  See `merge-component` and `merge-component!` for possibly more appropriate functions for your task.\n\n  Returns the new normalized database.","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",4,"~:max-fixed-arity",4,"~:method-params",["^1@",[["^6U","^6V","^6W"],["^6U","^6V","^6W",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^6S",["^1@",[["^6U","^6V","^6W"],["^6U","^6V","^6W",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"~:arglists-meta",["^1@",[null,null]]]],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge*","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",13,"^6[",["^ ","^70",false,"^71",4,"^72",4,"^73",["^1@",[["^6U","^6V","^6W"],["^6U","^6V","^6W",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^6S",["^1@",[["^6U","^6V","^6W"],["^6U","^6V","^6W",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^74",["^1@",[null,null]]],"^73",["^1@",[["^6U","^6V","^6W"],["^6U","^6V","^6W",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"~:protocol-impl",null,"^71",4,"^74",["^1@",[null,null]],"^9",1,"^70",false,"~:methods",[["^ ","^71",3,"^70",false,"~:tag","~$any"],["^ ","^71",4,"^70",false,"^78",["^O",[null,"^79"]]]],"^8",293,"^:",293,"^72",4,"~:fn-var",true,"^6S",["^1@",[["^6U","^6V","^6W"],["^6U","^6V","^6W",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^6","Merge the query-result of a query using Fulcro's standard merge and normalization logic.\n\n  Typically used on the state atom as:\n\n  ```\n  (swap! state merge* query-result query)\n  ```\n\n  - `state-map` - The normalized database.\n  - `query` - The query that was used to obtain the query-result. This query will be treated relative to the root of the database.\n  - `tree` - The query-result to merge (a map).\n\n  The options is a map containing:\n\n  * `:remove-missing?` If true (default false) then anything appearing in the `query` but not the `result-tree`\n  will be removed from `state-map`.\n\n  See `merge-component` and `merge-component!` for possibly more appropriate functions for your task.\n\n  Returns the new normalized database."],"~$merge-alternate-union-elements!",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",474,"^9",7,"^:",474,"^;",38,"^6S",["^1@",["^6T",["^1@",[["~$app","~$root-component"]]]]],"^6","Walks the query and initial state of root-component and merges the alternate sides of unions with initial state into\n  the application state database. See also `merge-alternate-union-elements`, which can be used on a state map and\n  is handy for server-side rendering. This function side-effects on your app, and returns nothing."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-alternate-union-elements!","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",38,"^73",["^1@",[["^7<","^7="]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",474,"~:ret-tag","^79","^:",474,"^72",2,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^7<","^7="]]]]],"^6","Walks the query and initial state of root-component and merges the alternate sides of unions with initial state into\n  the application state database. See also `merge-alternate-union-elements`, which can be used on a state map and\n  is handy for server-side rendering. This function side-effects on your app, and returns nothing."],"~$sweep-merge",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",178,"^9",7,"^:",178,"^;",18,"^6S",["^1@",["^6T",["^1@",[["~$target","~$source"]]]]],"^6","Do a recursive merge of source into target (both maps), but remove any target data that is marked as missing in the response.\n\n  Requires that the `source` has been marked via `mark-missing`.\n\n  The missing marker is generated in the source when something has been asked for in the query, but had no value in the\n  response. This allows us to correctly remove 'empty' data from the database without accidentally removing something\n  that may still exist on the server (in truth we don't know its status, since it wasn't asked for, but we leave\n  it as our 'best guess')."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/sweep-merge","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",18,"^73",["^1@",[["^7A","^7B"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",178,"^7?",["^O",[null,"^79"]],"^:",178,"^72",2,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^7A","^7B"]]]]],"^6","Do a recursive merge of source into target (both maps), but remove any target data that is marked as missing in the response.\n\n  Requires that the `source` has been marked via `mark-missing`.\n\n  The missing marker is generated in the source when something has been asked for in the query, but had no value in the\n  response. This allows us to correctly remove 'empty' data from the database without accidentally removing something\n  that may still exist on the server (in truth we don't know its status, since it wasn't asked for, but we leave\n  it as our 'best guess')."],"~$merge!",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",358,"^9",7,"^:",358,"^;",13,"^6S",["^1@",["^6T",["^1@",[["^7<","~$data-tree","^6V"],["^7<","^7E","^6V","^6Z"]]]]],"^6","Merge an arbitrary data-tree that conforms to the shape of the given query using Fulcro's\n  standard merge and normalization logic.\n\n  app - A fulcro application to merge into.\n  query - A query, derived from components, that can be used to normalized a tree of data.\n  data-tree - A tree of data that matches the nested shape of query.\n\n  The options is a map containing:\n\n  * `:remove-missing?` If true (default false) then anything appearing in the `query` but not the `result-tree`\n  will be removed from `state-map`.\n\n  NOTE: This function assumes you are merging against the root of the tree. See\n  `merge-component` and `merge-component!` for relative merging.\n\n  See also `merge*`.","^6[",["^ ","^70",false,"^71",4,"^72",4,"^73",["^1@",[["^7<","^7E","^6V"],["^7<","^7E","^6V","^6Z"]]],"^6S",["^1@",[["^7<","^7E","^6V"],["^7<","^7E","^6V","^6Z"]]],"^74",["^1@",[null,null]]]],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge!","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",13,"^6[",["^ ","^70",false,"^71",4,"^72",4,"^73",["^1@",[["^7<","^7E","^6V"],["^7<","^7E","^6V","^6Z"]]],"^6S",["^1@",[["^7<","^7E","^6V"],["^7<","^7E","^6V","^6Z"]]],"^74",["^1@",[null,null]]],"^73",["^1@",[["^7<","^7E","^6V"],["^7<","^7E","^6V","^6Z"]]],"^76",null,"^71",4,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^77",[["^ ","^71",3,"^70",false,"^78","^79"],["^ ","^71",4,"^70",false,"^78",["^O",[null,"^79","~$clj-nil"]]]],"^8",358,"^:",358,"^72",4,"^7:",true,"^6S",["^1@",[["^7<","^7E","^6V"],["^7<","^7E","^6V","^6Z"]]],"^6","Merge an arbitrary data-tree that conforms to the shape of the given query using Fulcro's\n  standard merge and normalization logic.\n\n  app - A fulcro application to merge into.\n  query - A query, derived from components, that can be used to normalized a tree of data.\n  data-tree - A tree of data that matches the nested shape of query.\n\n  The options is a map containing:\n\n  * `:remove-missing?` If true (default false) then anything appearing in the `query` but not the `result-tree`\n  will be removed from `state-map`.\n\n  NOTE: This function assumes you are merging against the root of the tree. See\n  `merge-component` and `merge-component!` for relative merging.\n\n  See also `merge*`."],"~$union->query",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",60,"^9",8,"^:",60,"^;",20,"~:private",true,"^6S",["^1@",["^6T",["^1@",[["~$union-query"]]]]],"^6","Turn a union query into a query that attempts to encompass all possible things that might be queried."],"^7I",true,"^P","~$com.fulcrologic.fulcro.algorithms.merge/union->query","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",20,"^73",["^1@",[["^7J"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",60,"^7?",["^O",["~$clj","~$cljs.core/IVector","^79","~$cljs.core/MetaFn","^7G"]],"^:",60,"^72",1,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^7J"]]]]],"^6","Turn a union query into a query that attempts to encompass all possible things that might be queried."],"~$merge-mutation-joins",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",227,"^9",7,"^:",227,"^;",27,"^6S",["^1@",["^6T",["^1@",[["~$state","^6V","^7E"],["^7P","^6V","^7E",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]]]],"^6","Merge all of the mutations that were joined with a query.\n\n  The options, if supplied, can include:\n\n  * `:remove-missing?`: (default false) If true then any items that appear in the `query` but not in the\n  `data-tree` will be removed from `state` (if present).","^6[",["^ ","^70",false,"^71",4,"^72",4,"^73",["^1@",[["^7P","^6V","^7E"],["^7P","^6V","^7E",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^6S",["^1@",[["^7P","^6V","^7E"],["^7P","^6V","^7E",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^74",["^1@",[null,null]]]],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-mutation-joins","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",27,"^6[",["^ ","^70",false,"^71",4,"^72",4,"^73",["^1@",[["^7P","^6V","^7E"],["^7P","^6V","^7E",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^6S",["^1@",[["^7P","^6V","^7E"],["^7P","^6V","^7E",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^74",["^1@",[null,null]]],"^73",["^1@",[["^7P","^6V","^7E"],["^7P","^6V","^7E",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^76",null,"^71",4,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^77",[["^ ","^71",3,"^70",false,"^78","^79"],["^ ","^71",4,"^70",false,"^78",["^O",[null,"^79"]]]],"^8",227,"^:",227,"^72",4,"^7:",true,"^6S",["^1@",[["^7P","^6V","^7E"],["^7P","^6V","^7E",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]],"^6","Merge all of the mutations that were joined with a query.\n\n  The options, if supplied, can include:\n\n  * `:remove-missing?`: (default false) If true then any items that appear in the `query` but not in the\n  `data-tree` will be removed from `state` (if present)."],"~$mark-missing",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",65,"^9",7,"^:",65,"^;",19,"^6S",["^1@",["^6T",["^1@",[["~$result","^6V"]]]]],"^6","Recursively walk the query and response marking anything that was *asked for* in the query but is *not* in the response as missing.\n  The sweep-merge process (which happens later in the plumbing) uses these markers as indicators to remove any existing\n  data in the target of the merge (i.e. your state database).\n\n  The naive approach to data merging (even recursive) would fail to remove such data.\n\n  Returns the result with missing markers in place (which are then used/removed in a later stage).\n\n  See the Developer Guide section on Fulcro's merge process for more information."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/mark-missing","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",19,"^73",["^1@",[["^7S","^6V"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",65,"^7?",["^O",[null,"^79"]],"^:",65,"^72",2,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^7S","^6V"]]]]],"^6","Recursively walk the query and response marking anything that was *asked for* in the query but is *not* in the response as missing.\n  The sweep-merge process (which happens later in the plumbing) uses these markers as indicators to remove any existing\n  data in the target of the merge (i.e. your state database).\n\n  The naive approach to data merging (even recursive) would fail to remove such data.\n\n  Returns the result with missing markers in place (which are then used/removed in a later stage).\n\n  See the Developer Guide section on Fulcro's merge process for more information."],"~$nilify-not-found",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",35,"^9",7,"^:",35,"^;",23,"^6S",["^1@",["^6T",["^1@",[["~$x"]]]]],"^6","Given x, return x value unless it's ::not-found (the mark/sweep missing marker), in which case it returns nil.\n\n  This is useful when you are pre-processing a tree that has been marked for missing data sweep (see `mark-missing`),\n  but has not yet been swept. This is basically the same as a `nil?` check in this circumstance since the given\n  value will be removed after the final sweep."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/nilify-not-found","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",23,"^73",["^1@",[["~$x"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",35,"^7?",["^O",[null,"^7G"]],"^:",35,"^72",1,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["~$x"]]]]],"^6","Given x, return x value unless it's ::not-found (the mark/sweep missing marker), in which case it returns nil.\n\n  This is useful when you are pre-processing a tree that has been marked for missing data sweep (see `mark-missing`),\n  but has not yet been swept. This is basically the same as a `nil?` check in this circumstance since the given\n  value will be removed after the final sweep."],"~$pre-merge-transform",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",217,"^9",7,"^:",217,"^;",26,"^6S",["^1@",["^6T",["^1@",[["^7P"],["^7P","^6Z"]]]]],"^6","Transform function that modifies data using component pre-merge hook.","^6[",["^ ","^70",false,"^71",2,"^72",2,"^73",["^1@",[["^7P"],["^7P","^6Z"]]],"^6S",["^1@",[["^7P"],["^7P","^6Z"]]],"^74",["^1@",[null,null]]]],"^P","~$com.fulcrologic.fulcro.algorithms.merge/pre-merge-transform","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",26,"^6[",["^ ","^70",false,"^71",2,"^72",2,"^73",["^1@",[["^7P"],["^7P","^6Z"]]],"^6S",["^1@",[["^7P"],["^7P","^6Z"]]],"^74",["^1@",[null,null]]],"^73",["^1@",[["^7P"],["^7P","^6Z"]]],"^76",null,"^71",2,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^77",[["^ ","^71",1,"^70",false,"^78","^79"],["^ ","^71",2,"^70",false,"^78","~$function"]],"^8",217,"^:",217,"^72",2,"^7:",true,"^6S",["^1@",[["^7P"],["^7P","^6Z"]]],"^6","Transform function that modifies data using component pre-merge hook."],"~$merge-ident",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",257,"^9",7,"^:",257,"^;",18,"^6S",["^1@",["^6T",["^1@",[["~$app-state","~$ident","~$props"]]]]]],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-ident","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",18,"^73",["^1@",[["^7[","^80","^81"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",257,"^7?",["^O",["^7L","^79"]],"^:",257,"^72",3,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^7[","^80","^81"]]]]]],"~$is-ui-query-fragment?",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",22,"^9",7,"^:",22,"^;",28,"^6S",["^1@",["^6T",["^1@",[["~$kw"]]]]],"^6","Check the given keyword to see if it is in the :ui namespace."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/is-ui-query-fragment?","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",28,"^73",["^1@",[["^84"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",22,"^7?",["^O",["^7L","^7M","^79","^7N","^7G"]],"^:",22,"^72",1,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^84"]]]]],"^6","Check the given keyword to see if it is in the :ui namespace."],"~$not-found?",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",28,"^9",7,"^:",28,"^;",17,"^6S",["^1@",["^6T",["^1@",[["^81","~$k"]]]]],"^6","Returns true if the `k` in `props` is the sweep-merge not-found marker. This marker appears\n  *during* merge, and can affect `:pre-merge` processing, since the data-tree will have these\n  markers when the given data is missing."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/not-found?","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",17,"^73",["^1@",[["^81","~$k"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",28,"^7?","~$boolean","^:",28,"^72",2,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^81","~$k"]]]]],"^6","Returns true if the `k` in `props` is the sweep-merge not-found marker. This marker appears\n  *during* merge, and can affect `:pre-merge` processing, since the data-tree will have these\n  markers when the given data is missing."],"~$component-merge-query",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",323,"^9",7,"^:",323,"^;",28,"^6S",["^1@",["^6T",["^1@",[["^6U","~$component","~$object-data"]]]]],"^6","Calculates the query that can be used to pull (or merge) a component with an ident\n  to/from a normalized app database. Requires a tree of data that represents the instance of\n  the component in question (e.g. ident will work on it)"],"^P","~$com.fulcrologic.fulcro.algorithms.merge/component-merge-query","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",28,"^73",["^1@",[["^6U","^8:","^8;"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",323,"^7?","^7M","^:",323,"^72",3,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^6U","^8:","^8;"]]]]],"^6","Calculates the query that can be used to pull (or merge) a component with an ident\n  to/from a normalized app database. Requires a tree of data that represents the instance of\n  the component in question (e.g. ident will work on it)"],"~$merge-alternate-union-elements",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",463,"^9",7,"^:",463,"^;",37,"^6S",["^1@",["^6T",["^1@",[["^6U","^7="]]]]],"^6","Just like merge-alternate-union-elements!, but usable from within mutations and on server-side rendering. Ensures\n  that when a component has initial state it will end up in the state map, even if it isn't currently in the\n  initial state of the union component (which can only point to one at a time)."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-alternate-union-elements","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",37,"^73",["^1@",[["^6U","^7="]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",463,"^7?","^79","^:",463,"^72",2,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^6U","^7="]]]]],"^6","Just like merge-alternate-union-elements!, but usable from within mutations and on server-side rendering. Ensures\n  that when a component has initial state it will end up in the state map, even if it isn't currently in the\n  initial state of the union component (which can only point to one at a time)."],"~$remove-ident*",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",13,"^9",7,"^:",13,"^;",20,"^6S",["^1@",["^6T",["^1@",[["^6U","^80","~$path-to-idents"]]]]],"^6","Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/remove-ident*","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",20,"^73",["^1@",[["^6U","^80","^8@"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",13,"^7?",["^O",["^7L","^79"]],"^:",13,"^72",3,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^6U","^80","^8@"]]]]],"^6","Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations."],"~$component-pre-merge",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",201,"^9",8,"^:",201,"^;",27,"^7I",true,"^6S",["^1@",["^6T",["^1@",[["~$class","^6V","^7P","~$data",["^ ","^6X",["^6Y"]]]]]]]],"^7I",true,"^P","~$com.fulcrologic.fulcro.algorithms.merge/component-pre-merge","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",27,"^73",["^1@",[["^8C","^6V","^7P","^8D","~$p__63857"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",201,"^7?",["^O",[null,"^79","^7G"]],"^:",201,"^72",5,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^8C","^6V","^7P","^8D",["^ ","^6X",["^6Y"]]]]]]]],"~$sweep-one",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",150,"^9",8,"^:",150,"^;",17,"^7I",true,"^6S",["^1@",["^6T",["^1@",[["~$m"]]]]],"^6","Remove not-found keys from m (non-recursive). `m` can be a map (sweep the values) or vector (run sweep-one on each entry)."],"^7I",true,"^P","~$com.fulcrologic.fulcro.algorithms.merge/sweep-one","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",17,"^73",["^1@",[["~$m"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",150,"^7?",["^O",[null,"^7L","^79","^7N","^7G"]],"^:",150,"^72",1,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["~$m"]]]]],"^6","Remove not-found keys from m (non-recursive). `m` can be a map (sweep the values) or vector (run sweep-one on each entry)."],"~$merge-component!",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",424,"^9",7,"^:",424,"^;",23,"^6S",["^1@",["^6T",["^1@",[["^7<","^8:","^8;","~$&","~$named-parameters"]]]]],"^6","Normalize and merge a (sub)tree of application state into the application using a known UI component's query and ident.\n\n  This utility function obtains the ident of the incoming object-data using the UI component's ident function. Once obtained,\n  it uses the component's query and ident to normalize the data and places the resulting objects in the correct tables.\n  It is also quite common to want those new objects to be linked into lists in other spots in app state, so this function\n  supports optional named parameters for doing this. These named parameters can be repeated as many times as you like in order\n  to place the ident of the new object into other data structures of app state.\n\n  This function honors the data merge story for Fulcro: attributes that are queried for but do not appear in the\n  data will be removed from the application. This function also uses the initial state for the component as a base\n  for merge if there was no state for the object already in the database.\n\n  This function will also trigger re-renders of components that directly render object merged, as well as any components\n  into which you integrate that data via the named-parameters.\n\n  This function is primarily meant to be used from things like server push and setTimeout/setInterval, where you're outside\n  of the normal mutation story. Do not use this function within abstract mutations.\n\n  * `app`: Your application.\n  * `component`: The class of the component that corresponds to the data. Must have an ident.\n  * `object-data`: A map (tree) of data to merge. Will be normalized for you.\n  * `named-parameter`: Post-processing ident integration steps. see `targeting/integrate-ident*`. You may also\n  include `:remove-missing? true/false` to indicate that data that is missing for the component's query\n  should be removed from app state.\n\n  Any keywords that appear in ident integration steps will be added to the re-render queue.\n\n  See also `fulcro.client.primitives/merge!`.\n  ","^6[",["^ ","^70",true,"^71",3,"^72",3,"^73",[["^1@",["^7<","^8:","^8;","^8J"]]],"^6S",["^1@",[["^7<","^8:","^8;","~$&","^8J"]]],"^74",["^1@",[null]]]],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-component!","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",23,"^6[",["^ ","^70",true,"^71",3,"^72",3,"^73",[["^1@",["^7<","^8:","^8;","^8J"]]],"^6S",["^1@",[["^7<","^8:","^8;","~$&","^8J"]]],"^74",["^1@",[null]]],"^73",[["^1@",["^7<","^8:","^8;","^8J"]]],"^76",null,"^71",3,"^74",["^1@",[null]],"^9",1,"^70",true,"^77",[["^ ","^71",3,"^70",true,"^78",["^O",["^79","^7G"]]]],"^8",424,"^7?","^79","^:",424,"^72",3,"^7:",true,"^6S",["^1@",[["^7<","^8:","^8;","~$&","^8J"]]],"^6","Normalize and merge a (sub)tree of application state into the application using a known UI component's query and ident.\n\n  This utility function obtains the ident of the incoming object-data using the UI component's ident function. Once obtained,\n  it uses the component's query and ident to normalize the data and places the resulting objects in the correct tables.\n  It is also quite common to want those new objects to be linked into lists in other spots in app state, so this function\n  supports optional named parameters for doing this. These named parameters can be repeated as many times as you like in order\n  to place the ident of the new object into other data structures of app state.\n\n  This function honors the data merge story for Fulcro: attributes that are queried for but do not appear in the\n  data will be removed from the application. This function also uses the initial state for the component as a base\n  for merge if there was no state for the object already in the database.\n\n  This function will also trigger re-renders of components that directly render object merged, as well as any components\n  into which you integrate that data via the named-parameters.\n\n  This function is primarily meant to be used from things like server push and setTimeout/setInterval, where you're outside\n  of the normal mutation story. Do not use this function within abstract mutations.\n\n  * `app`: Your application.\n  * `component`: The class of the component that corresponds to the data. Must have an ident.\n  * `object-data`: A map (tree) of data to merge. Will be normalized for you.\n  * `named-parameter`: Post-processing ident integration steps. see `targeting/integrate-ident*`. You may also\n  include `:remove-missing? true/false` to indicate that data that is missing for the component's query\n  should be removed from app state.\n\n  Any keywords that appear in ident integration steps will be added to the re-render queue.\n\n  See also `fulcro.client.primitives/merge!`.\n  "],"~$sweep",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",162,"^9",7,"^:",162,"^;",12,"^6S",["^1@",["^6T",["^1@",[["~$m"]]]]],"^6","Remove all of the not-found keys (recursively) from m, stopping at marked leaves (if present). Requires `m`\n  to have been pre-marked via `mark-missing`."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/sweep","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",12,"^73",["^1@",[["~$m"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",162,"^7?",["^O",[null,"^7L","^79","^7N","^7G"]],"^:",162,"^72",1,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["~$m"]]]]],"^6","Remove all of the not-found keys (recursively) from m, stopping at marked leaves (if present). Requires `m`\n  to have been pre-marked via `mark-missing`."],"~$merge-component",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",383,"^9",7,"^:",383,"^;",22,"^6S",["^1@",["^6T",["^1@",[["^6U","^8:","~$component-data","~$&","^8J"]]]]],"^6","Given a state map of the application database, a component, and a tree of component-data: normalizes\n   the tree of data and merges the component table entries into the state, returning a new state map.\n\n   Since there is not an implied root, the component itself won't be linked into your graph (though it will\n   remain correctly linked for its own consistency).\n\n   * `state-map` - The normalized database\n   * `component` - A component class\n   * `component-data` - A tree of data that matches the shape of the component's query.\n   * `named-parameters` - Parameters from `targeting/integrate-ident*` that will let you link the merged component into the graph.\n   Named parameters may also include `:remove-missing?`, which will remove things that are queried for but do\n   not appear in the data from the state.\n\n   See also targeting/integrate-ident*, and merge/merge-component!","^6[",["^ ","^70",true,"^71",3,"^72",3,"^73",[["^1@",["^6U","^8:","^8O","^8J"]]],"^6S",["^1@",[["^6U","^8:","^8O","~$&","^8J"]]],"^74",["^1@",[null]]]],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-component","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",22,"^6[",["^ ","^70",true,"^71",3,"^72",3,"^73",[["^1@",["^6U","^8:","^8O","^8J"]]],"^6S",["^1@",[["^6U","^8:","^8O","~$&","^8J"]]],"^74",["^1@",[null]]],"^73",[["^1@",["^6U","^8:","^8O","^8J"]]],"^76",null,"^71",3,"^74",["^1@",[null]],"^9",1,"^70",true,"^77",[["^ ","^71",3,"^70",true,"^78",["^O",[null,"^7L","^7G"]]]],"^8",383,"^7?","^79","^:",383,"^72",3,"^7:",true,"^6S",["^1@",[["^6U","^8:","^8O","~$&","^8J"]]],"^6","Given a state map of the application database, a component, and a tree of component-data: normalizes\n   the tree of data and merges the component table entries into the state, returning a new state map.\n\n   Since there is not an implied root, the component itself won't be linked into your graph (though it will\n   remain correctly linked for its own consistency).\n\n   * `state-map` - The normalized database\n   * `component` - A component class\n   * `component-data` - A tree of data that matches the shape of the component's query.\n   * `named-parameters` - Parameters from `targeting/integrate-ident*` that will let you link the merged component into the graph.\n   Named parameters may also include `:remove-missing?`, which will remove things that are queried for but do\n   not appear in the data from the state.\n\n   See also targeting/integrate-ident*, and merge/merge-component!"],"~$sift-idents",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",260,"^9",8,"^:",260,"^;",19,"^7I",true,"^6S",["^1@",["^6T",["^1@",[["~$res"]]]]]],"^7I",true,"^P","~$com.fulcrologic.fulcro.algorithms.merge/sift-idents","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",19,"^73",["^1@",[["^8R"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",260,"^7?","^7M","^:",260,"^72",1,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^8R"]]]]]],"~$leaf?",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",51,"^9",8,"^:",51,"^;",13,"^7I",true,"^6S",["^1@",["^6T",["^1@",[["^8D"]]]]],"^6","Returns true iff the given data is marked as a leaf in the result (according to the query). Requires pre-marking."],"^7I",true,"^P","~$com.fulcrologic.fulcro.algorithms.merge/leaf?","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",13,"^73",["^1@",[["^8D"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",51,"^7?","^88","^:",51,"^72",1,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^8D"]]]]],"^6","Returns true iff the given data is marked as a leaf in the result (according to the query). Requires pre-marking."],"~$merge-idents",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",273,"^9",7,"^:",273,"^;",19,"^6S",["^1@",["^6T",["^1@",[["~$tree","^6V","~$refs",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]]]],"^6","Merge the given `refs` (a map from ident to props), query (a query that contains ident-joins), and tree:\n\n  returns a new tree with the data merged into the proper ident-based tables."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-idents","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",19,"^73",["^1@",[["^8W","^6V","^8X","~$p__63896"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",273,"^:",273,"^72",4,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^8W","^6V","^8X",["^ ","^6X",["^6Y"],"^1B","^6Z"]]]]]],"^6","Merge the given `refs` (a map from ident to props), query (a query that contains ident-joins), and tree:\n\n  returns a new tree with the data merged into the proper ident-based tables."],"~$merge-alternate-unions",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",332,"^9",7,"^:",332,"^;",29,"^6S",["^1@",["^6T",["^1@",[["~$merge-fn","^7="]]]]],"^6","Walks the given query and calls (merge-fn parent-union-component union-child-initial-state) for each non-default element of a union that has initial app state.\n  You probably want to use merge-alternate-union-elements[!] on a state map or app."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-alternate-unions","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",29,"^73",["^1@",[["^90","^7="]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",332,"^:",332,"^72",2,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^90","^7="]]]]],"^6","Walks the given query and calls (merge-fn parent-union-component union-child-initial-state) for each non-default element of a union that has initial app state.\n  You probably want to use merge-alternate-union-elements[!] on a state map or app."],"~$merge-tree",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",264,"^9",7,"^:",264,"^;",17,"^6S",["^1@",["^6T",["^1@",[["^7A","^7B"]]]]],"^6","Handle merging incoming data and sweep it of values that are marked missing. This function also ensures that raw\n   mutation join results are ignored (they must be merged via `merge-mutation-joins`)."],"^P","~$com.fulcrologic.fulcro.algorithms.merge/merge-tree","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",17,"^73",["^1@",[["^7A","^7B"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",264,"^7?",["^O",[null,"^79"]],"^:",264,"^72",2,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^7A","^7B"]]]]],"^6","Handle merging incoming data and sweep it of values that are marked missing. This function also ensures that raw\n   mutation join results are ignored (they must be merged via `merge-mutation-joins`)."],"~$as-leaf",["^ ","^6R",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",44,"^9",8,"^:",44,"^;",15,"^7I",true,"^6S",["^1@",["^6T",["^1@",[["^8D"]]]]],"^6","Returns `data` with meta-data that marks it as a leaf in the result."],"^7I",true,"^P","~$com.fulcrologic.fulcro.algorithms.merge/as-leaf","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",15,"^73",["^1@",[["^8D"]]],"^76",null,"^74",["^1@",[null,null]],"^9",1,"^70",false,"^8",44,"^7?",["^O",[null,"^7L","^7N","^7G"]],"^:",44,"^72",1,"^7:",true,"^6S",["^1@",["^6T",["^1@",[["^8D"]]]]],"^6","Returns `data` with meta-data that marks it as a leaf in the result."]],"^1>",["^ ","^B","^B","^Z","^[","^12","^13","^13","^13","^[","^["],"~:cljs.analyzer/constants",["^ ","^1;",["^O",["~:state-map","~:tempids","~:children","~:union-key","~:key","~:union-entry","~:else","~:replace","~:remove-missing?","~:prepend","~:fulcro/leaf","~$*","~:append","~:com.fulcrologic.fulcro.algorithms.data-targeting/target","~:type","~:current-normalized","~$_","~:component","~:schedule-render!","~:com.fulcrologic.fulcro.application/state-atom","~:otherwise","~:dispatch-key","~:com.fulcrologic.fulcro.algorithms.merge/temporary-key","~:error","~:com.fulcrologic.fulcro.algorithms.merge/merge","~:query","~:union","~$...","~:auto","~:p","~:com.fulcrologic.fulcro.algorithms.merge/not-found","~:data-tree"]],"~:order",["^9R","^9A","^9=","~$_","^9P","^9I","^98","^9?","^97","^9E","^9S","^9N","^9F","^9C","^9K","~$*","^99","^9D","^9J","^9:","^9;","^9<","^9O","^9H","^9M","^9>","^9@","^9B","^9L","~:p","^9Q","^9G"]],"^1C",["^ ","^1<",["^O",[]]],"^1D",["^ "],"^1E",["^17","^B","^11","^13","^W","^Y","^15","^19","^X","^["]],"^S","^Q","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1S",[["^9W","~:static-fns"],true,["^9W","~:elide-asserts"],false,["^9W","~:optimize-constants"],null,["^9W","^1J"],null,["^9W","~:external-config"],null,["^9W","~:tooling-config"],null,["^9W","~:emit-constants"],null,["^9W","~:load-tests"],null,["^9W","~:form-size-threshold"],null,["^9W","~:infer-externs"],true,["^9W","^1L"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^9W","~:fn-invoke-direct"],null,["^9W","~:source-map"],"/dev/null"]]]