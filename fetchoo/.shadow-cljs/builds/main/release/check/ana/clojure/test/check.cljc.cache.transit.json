["^ ","~:output",["^ ","~:js","goog.provide('clojure.test.check');\n\nclojure.test.check.make_rng = (function clojure$test$check$make_rng(seed){\nif(cljs.core.truth_(seed)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [seed,clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1(seed)], null);\n} else {\nvar non_nil_seed = clojure.test.check.impl.get_current_time_millis();\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [non_nil_seed,clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1(non_nil_seed)], null);\n}\n});\nclojure.test.check.complete = (function clojure$test$check$complete(property,num_trials,seed,start_time,reporter_fn){\nvar time_elapsed_ms = (clojure.test.check.impl.get_current_time_millis() - start_time);\nvar G__69424_69587 = new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"complete\",\"complete\",-500388775),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),property,new cljs.core.Keyword(null,\"result\",\"result\",1415092211),true,new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),true,new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),num_trials,new cljs.core.Keyword(null,\"time-elapsed-ms\",\"time-elapsed-ms\",-755913315),time_elapsed_ms,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),seed], null);\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__69424_69587) : reporter_fn.call(null,G__69424_69587));\n\nreturn new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"result\",\"result\",1415092211),true,new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),true,new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),num_trials,new cljs.core.Keyword(null,\"time-elapsed-ms\",\"time-elapsed-ms\",-755913315),time_elapsed_ms,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),seed], null);\n});\n/**\n * Returns a value for the legacy :result key, which has the peculiar\n *   property of conflating returned exceptions with thrown exceptions.\n */\nclojure.test.check.legacy_result = (function clojure$test$check$legacy_result(result){\nif((((!((result == null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL === result.clojure$test$check$results$Result$))))?true:(((!result.cljs$lang$protocol_mask$partition$))?cljs.core.native_satisfies_QMARK_(clojure.test.check.results.Result,result):false)):cljs.core.native_satisfies_QMARK_(clojure.test.check.results.Result,result))){\nvar d = clojure.test.check.results.result_data(result);\nvar temp__5751__auto__ = cljs.core.find(d,new cljs.core.Keyword(\"clojure.test.check.properties\",\"error\",\"clojure.test.check.properties/error\",483933635));\nif(cljs.core.truth_(temp__5751__auto__)){\nvar vec__69440 = temp__5751__auto__;\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__69440,(0),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__69440,(1),null);\nif((e instanceof Error)){\nreturn e;\n} else {\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3(\"Non-Error object thrown in test\",cljs.core.PersistentArrayMap.EMPTY,e);\n}\n} else {\nreturn clojure.test.check.results.pass_QMARK_(result);\n}\n} else {\nreturn result;\n}\n});\n/**\n * Tests `property` `num-tests` times.\n * \n *   Takes several optional keys:\n * \n *   `:seed`\n *  Can be used to re-run previous tests, as the seed used is returned\n *  after a test is run.\n * \n *   `:max-size`.\n *  can be used to control the 'size' of generated values. The size will\n *  start at 0, and grow up to max-size, as the number of tests increases.\n *  Generators will use the size parameter to bound their growth. This\n *  prevents, for example, generating a five-thousand element vector on\n *  the very first test.\n * \n *   `:reporter-fn`\n *  A callback function that will be called at various points in the test\n *  run, with a map like:\n * \n *    ;; called after a passing trial\n *    {:type            :trial\n *     :args            [...]\n *     :num-tests       <number of tests run so far>\n *     :num-tests-total <total number of tests to be run>\n *     :seed            42\n *     :pass?           true\n *     :property        #<...>\n *     :result          true\n *     :result-data     {...}}\n * \n *    ;; called after the first failing trial\n *    {:type         :failure\n *     :fail         [...failing args...]\n *     :failing-size 13\n *     :num-tests    <tests ran before failure found>\n *     :pass?        false\n *     :property     #<...>\n *     :result       false/exception\n *     :result-data  {...}\n *     :seed         42}\n * \n *  It will also be called on :complete, :shrink-step and :shrunk.\n * \n *   Examples:\n * \n *    (def p (for-all [a gen/pos-int] (> (* a a) a)))\n * \n *    (quick-check 100 p)\n *    (quick-check 200 p\n *                 :seed 42\n *                 :max-size 50\n *                 :reporter-fn (fn [m]\n *                                (when (= :failure (:type m))\n *                                  (println \"Uh oh...\"))))\n * @param {...*} var_args\n */\nclojure.test.check.quick_check = (function clojure$test$check$quick_check(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___69606 = arguments.length;\nvar i__4731__auto___69607 = (0);\nwhile(true){\nif((i__4731__auto___69607 < len__4730__auto___69606)){\nargs__4736__auto__.push((arguments[i__4731__auto___69607]));\n\nvar G__69609 = (i__4731__auto___69607 + (1));\ni__4731__auto___69607 = G__69609;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((2) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((2)),(0),null)):null);\nreturn clojure.test.check.quick_check.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4737__auto__);\n});\n\nclojure.test.check.quick_check.cljs$core$IFn$_invoke$arity$variadic = (function (num_tests,property,p__69454){\nvar map__69455 = p__69454;\nvar map__69455__$1 = (((((!((map__69455 == null))))?(((((map__69455.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__69455.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__69455):map__69455);\nvar seed = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__69455__$1,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327));\nvar max_size = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__69455__$1,new cljs.core.Keyword(null,\"max-size\",\"max-size\",-874966132),(200));\nvar reporter_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__69455__$1,new cljs.core.Keyword(null,\"reporter-fn\",\"reporter-fn\",1280520247),cljs.core.constantly(null));\nvar vec__69463 = clojure.test.check.make_rng(seed);\nvar created_seed = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__69463,(0),null);\nvar rng = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__69463,(1),null);\nvar size_seq = clojure.test.check.generators.make_size_range_seq(max_size);\nvar start_time = clojure.test.check.impl.get_current_time_millis();\nvar so_far = (0);\nvar size_seq__$1 = size_seq;\nvar rstate = rng;\nwhile(true){\nif((so_far === num_tests)){\nreturn clojure.test.check.complete(property,num_tests,created_seed,start_time,reporter_fn);\n} else {\nvar vec__69488 = size_seq__$1;\nvar seq__69489 = cljs.core.seq(vec__69488);\nvar first__69490 = cljs.core.first(seq__69489);\nvar seq__69489__$1 = cljs.core.next(seq__69489);\nvar size = first__69490;\nvar rest_size_seq = seq__69489__$1;\nvar vec__69491 = clojure.test.check.random.split(rstate);\nvar r1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__69491,(0),null);\nvar r2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__69491,(1),null);\nvar result_map_rose = clojure.test.check.generators.call_gen(property,r1,size);\nvar result_map = clojure.test.check.rose_tree.root(result_map_rose);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(result_map);\nvar args = new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(result_map);\nvar so_far__$1 = (so_far + (1));\nif(cljs.core.truth_(clojure.test.check.results.pass_QMARK_(result))){\nvar G__69500_69621 = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"args\",\"args\",1315556576),new cljs.core.Keyword(null,\"num-tests-total\",\"num-tests-total\",-2113009946),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),new cljs.core.Keyword(null,\"result\",\"result\",1415092211),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753)],[args,num_tests,property,so_far__$1,new cljs.core.Keyword(null,\"trial\",\"trial\",-677458347),seed,result,clojure.test.check.results.result_data(result),true]);\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__69500_69621) : reporter_fn.call(null,G__69500_69621));\n\nvar G__69625 = so_far__$1;\nvar G__69626 = rest_size_seq;\nvar G__69627 = r2;\nso_far = G__69625;\nsize_seq__$1 = G__69626;\nrstate = G__69627;\ncontinue;\n} else {\nreturn (clojure.test.check.failure.cljs$core$IFn$_invoke$arity$7 ? clojure.test.check.failure.cljs$core$IFn$_invoke$arity$7(property,result_map_rose,so_far__$1,size,created_seed,start_time,reporter_fn) : clojure.test.check.failure.call(null,property,result_map_rose,so_far__$1,size,created_seed,start_time,reporter_fn));\n}\n}\nbreak;\n}\n});\n\nclojure.test.check.quick_check.cljs$lang$maxFixedArity = (2);\n\n/** @this {Function} */\nclojure.test.check.quick_check.cljs$lang$applyTo = (function (seq69449){\nvar G__69450 = cljs.core.first(seq69449);\nvar seq69449__$1 = cljs.core.next(seq69449);\nvar G__69451 = cljs.core.first(seq69449__$1);\nvar seq69449__$2 = cljs.core.next(seq69449__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__69450,G__69451,seq69449__$2);\n});\n\nclojure.test.check.smallest_shrink = (function clojure$test$check$smallest_shrink(total_nodes_visited,depth,smallest,start_time){\nvar map__69512 = smallest;\nvar map__69512__$1 = (((((!((map__69512 == null))))?(((((map__69512.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__69512.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__69512):map__69512);\nvar result = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__69512__$1,new cljs.core.Keyword(null,\"result\",\"result\",1415092211));\nreturn new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"total-nodes-visited\",\"total-nodes-visited\",-620132443),total_nodes_visited,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),depth,new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),false,new cljs.core.Keyword(null,\"result\",\"result\",1415092211),clojure.test.check.legacy_result(result),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),clojure.test.check.results.result_data(result),new cljs.core.Keyword(null,\"time-shrinking-ms\",\"time-shrinking-ms\",-383238219),(clojure.test.check.impl.get_current_time_millis() - start_time),new cljs.core.Keyword(null,\"smallest\",\"smallest\",-152623883),new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(smallest)], null);\n});\n/**\n * Shrinking a value produces a sequence of smaller values of the same type.\n *   Each of these values can then be shrunk. Think of this as a tree. We do a\n *   modified depth-first search of the tree:\n * \n *   Do a non-exhaustive search for a deeper (than the root) failing example.\n *   Additional rules added to depth-first search:\n *   * If a node passes the property, you may continue searching at this depth,\n *   but not backtrack\n *   * If a node fails the property, search its children\n *   The value returned is the left-most failing example at the depth where a\n *   passing example was found.\n * \n *   Calls reporter-fn on every shrink step.\n */\nclojure.test.check.shrink_loop = (function clojure$test$check$shrink_loop(rose_tree,reporter_fn){\nvar start_time = clojure.test.check.impl.get_current_time_millis();\nvar shrinks_this_depth = clojure.test.check.rose_tree.children(rose_tree);\nvar nodes = shrinks_this_depth;\nvar current_smallest = clojure.test.check.rose_tree.root(rose_tree);\nvar total_nodes_visited = (0);\nvar depth = (0);\nwhile(true){\nif(cljs.core.empty_QMARK_(nodes)){\nreturn clojure.test.check.smallest_shrink(total_nodes_visited,depth,current_smallest,start_time);\n} else {\nvar head = cljs.core.first(nodes);\nvar tail = cljs.core.rest(nodes);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(clojure.test.check.rose_tree.root(head));\nvar args = new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(clojure.test.check.rose_tree.root(head));\nvar pass_QMARK_ = clojure.test.check.results.pass_QMARK_(result);\nvar reporter_fn_arg = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"shrink-step\",\"shrink-step\",-541828120),new cljs.core.Keyword(null,\"shrinking\",\"shrinking\",2049648186),new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"args\",\"args\",1315556576),args,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),depth,new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),cljs.core.boolean$(pass_QMARK_),new cljs.core.Keyword(null,\"result\",\"result\",1415092211),result,new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),clojure.test.check.results.result_data(result),new cljs.core.Keyword(null,\"smallest\",\"smallest\",-152623883),new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(current_smallest),new cljs.core.Keyword(null,\"total-nodes-visited\",\"total-nodes-visited\",-620132443),total_nodes_visited], null)], null);\nif(cljs.core.truth_(pass_QMARK_)){\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(reporter_fn_arg) : reporter_fn.call(null,reporter_fn_arg));\n\nvar G__69652 = tail;\nvar G__69653 = current_smallest;\nvar G__69654 = (total_nodes_visited + (1));\nvar G__69655 = depth;\nnodes = G__69652;\ncurrent_smallest = G__69653;\ntotal_nodes_visited = G__69654;\ndepth = G__69655;\ncontinue;\n} else {\nvar new_smallest = clojure.test.check.rose_tree.root(head);\nvar G__69543_69657 = cljs.core.assoc_in(reporter_fn_arg,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"shrinking\",\"shrinking\",2049648186),new cljs.core.Keyword(null,\"smallest\",\"smallest\",-152623883)], null),new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(new_smallest));\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__69543_69657) : reporter_fn.call(null,G__69543_69657));\n\nvar temp__5751__auto__ = cljs.core.seq(clojure.test.check.rose_tree.children(head));\nif(temp__5751__auto__){\nvar children = temp__5751__auto__;\nvar G__69659 = children;\nvar G__69660 = new_smallest;\nvar G__69661 = (total_nodes_visited + (1));\nvar G__69662 = (depth + (1));\nnodes = G__69659;\ncurrent_smallest = G__69660;\ntotal_nodes_visited = G__69661;\ndepth = G__69662;\ncontinue;\n} else {\nvar G__69666 = tail;\nvar G__69667 = new_smallest;\nvar G__69668 = (total_nodes_visited + (1));\nvar G__69669 = depth;\nnodes = G__69666;\ncurrent_smallest = G__69667;\ntotal_nodes_visited = G__69668;\ndepth = G__69669;\ncontinue;\n}\n}\n}\nbreak;\n}\n});\nclojure.test.check.failure = (function clojure$test$check$failure(property,failing_rose_tree,trial_number,size,seed,start_time,reporter_fn){\nvar failed_after_ms = (clojure.test.check.impl.get_current_time_millis() - start_time);\nvar root = clojure.test.check.rose_tree.root(failing_rose_tree);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(root);\nvar failure_data = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"failed-after-ms\",\"failed-after-ms\",912141156),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930),new cljs.core.Keyword(null,\"result\",\"result\",1415092211),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),new cljs.core.Keyword(null,\"failing-size\",\"failing-size\",-429562538),new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753)],[failed_after_ms,property,trial_number,seed,new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(root),clojure.test.check.legacy_result(result),clojure.test.check.results.result_data(result),size,false]);\nvar G__69568_69674 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(failure_data,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"failure\",\"failure\",720415879));\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__69568_69674) : reporter_fn.call(null,G__69568_69674));\n\nvar shrunk = clojure.test.check.shrink_loop(failing_rose_tree,((function (failed_after_ms,root,result,failure_data){\nreturn (function (p1__69552_SHARP_){\nvar G__69571 = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([failure_data,p1__69552_SHARP_], 0));\nreturn (reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__69571) : reporter_fn.call(null,G__69571));\n});})(failed_after_ms,root,result,failure_data))\n);\nvar G__69573_69678 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(failure_data,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),shrunk], 0));\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__69573_69678) : reporter_fn.call(null,G__69573_69678));\n\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(failure_data,new cljs.core.Keyword(null,\"property\",\"property\",-1114278232)),new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),shrunk);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check.cljc","~:line",10,"~:column",5,"~:end-line",10,"~:end-column",23],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.test","~$cljs.test","~$clojure.core","~$cljs.core","~$clojure.spec.test.alpha","~$cljs.spec.test.alpha","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha","~$clojure.pprint","~$cljs.pprint","~$clojure.core.async","~$cljs.core.async"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.test.check.results","^U","~$rose","~$clojure.test.check.rose-tree","~$results","^U","~$clojure.test.check.impl","^Y","^W","^W","^C","^C","~$clojure.test.check.generators","^Z","~$goog","^[","~$gen","^Z","~$clojure.test.check.random","^11","~$random","^11"],"~:seen",["^N",["~:require"]],"~:uses",["^ ","~$get-current-time-millis","^Y"],"~:require-macros",["^ ","^C","^C","^Z","^Z","^10","^Z"],"~:form",["~#list",["~$ns","^P",["^19",["^14",["^Z","~:as","^10"],["^11","^1;","^12"],["^U","^1;","^X"],["^W","^1;","^V"],["^Y","~:refer",["^16"]]]]]],"~:flags",["^ ","^14",["^N",[]]],"~:js-deps",["^ "],"~:deps",["^[","^C","^Z","^11","^U","^W","^Y"]],"^R","^P","~:resource-id",["~:shadow.build.classpath/resource","clojure/test/check.cljc"],"~:compiled-at",1630228760437,"~:resource-name","clojure/test/check.cljc","~:warnings",[],"~:source",";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check\n  (:require [clojure.test.check.generators :as gen]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.results :as results]\n            [clojure.test.check.rose-tree :as rose]\n            [clojure.test.check.impl :refer [get-current-time-millis]]))\n\n(declare shrink-loop failure)\n\n(defn- make-rng\n  [seed]\n  (if seed\n    [seed (random/make-random seed)]\n    (let [non-nil-seed (get-current-time-millis)]\n      [non-nil-seed (random/make-random non-nil-seed)])))\n\n(defn- complete\n  [property num-trials seed start-time reporter-fn]\n  (let [time-elapsed-ms (- (get-current-time-millis) start-time)]\n    (reporter-fn {:type :complete\n                  :property property\n                  :result true\n                  :pass? true\n                  :num-tests num-trials\n                  :time-elapsed-ms time-elapsed-ms\n                  :seed seed})\n    {:result true\n     :pass? true\n     :num-tests num-trials\n     :time-elapsed-ms time-elapsed-ms\n     :seed seed}))\n\n\n(defn ^:private legacy-result\n  \"Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions.\"\n  [result]\n  (if (satisfies? results/Result result)\n    (let [d (results/result-data result)]\n      (if-let [[_ e] (find d :clojure.test.check.properties/error)]\n        #?(:clj e\n           :cljs (if (instance? js/Error e)\n                   e\n                   (ex-info \"Non-Error object thrown in test\"\n                            {}\n                            e)))\n        (results/pass? result)))\n    result))\n\n(defn quick-check\n  \"Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \\\"Uh oh...\\\"))))\"\n  [num-tests property & {:keys [seed max-size reporter-fn]\n                         :or {max-size 200, reporter-fn (constantly nil)}}]\n  (let [[created-seed rng] (make-rng seed)\n        size-seq (gen/make-size-range-seq max-size)\n        start-time (get-current-time-millis)]\n    (loop [so-far 0\n           size-seq size-seq\n           rstate rng]\n      (if (== so-far num-tests)\n        (complete property num-tests created-seed start-time reporter-fn)\n        (let [[size & rest-size-seq] size-seq\n              [r1 r2] (random/split rstate)\n              result-map-rose (gen/call-gen property r1 size)\n              result-map (rose/root result-map-rose)\n              result (:result result-map)\n              args (:args result-map)\n              so-far (inc so-far)]\n          (if (results/pass? result)\n            (do\n              (reporter-fn {:type            :trial\n                            :args            args\n                            :num-tests       so-far\n                            :num-tests-total num-tests\n                            :pass?           true\n                            :property        property\n                            :result          result\n                            :result-data     (results/result-data result)\n                            :seed            seed})\n              (recur so-far rest-size-seq r2))\n            (failure property result-map-rose so-far size\n                     created-seed start-time reporter-fn)))))))\n\n(defn- smallest-shrink\n  [total-nodes-visited depth smallest start-time]\n  (let [{:keys [result]} smallest]\n    {:total-nodes-visited total-nodes-visited\n     :depth depth\n     :pass? false\n     :result (legacy-result result)\n     :result-data (results/result-data result)\n     :time-shrinking-ms (- (get-current-time-millis) start-time)\n     :smallest (:args smallest)}))\n\n(defn- shrink-loop\n  \"Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step.\"\n  [rose-tree reporter-fn]\n  (let [start-time (get-current-time-millis)\n        shrinks-this-depth (rose/children rose-tree)]\n    (loop [nodes shrinks-this-depth\n           current-smallest (rose/root rose-tree)\n           total-nodes-visited 0\n           depth 0]\n      (if (empty? nodes)\n        (smallest-shrink total-nodes-visited depth current-smallest start-time)\n        (let [;; can't destructure here because that could force\n              ;; evaluation of (second nodes)\n              head (first nodes)\n              tail (rest nodes)\n              result (:result (rose/root head))\n              args (:args (rose/root head))\n              pass? (results/pass? result)\n              reporter-fn-arg {:type :shrink-step\n                               :shrinking {:args                args\n                                           :depth               depth\n                                           :pass?               (boolean pass?)\n                                           :result              result\n                                           :result-data         (results/result-data result)\n                                           :smallest            (:args current-smallest)\n                                           :total-nodes-visited total-nodes-visited}}]\n          (if pass?\n            ;; this node passed the test, so now try testing its right-siblings\n            (do\n              (reporter-fn reporter-fn-arg)\n              (recur tail current-smallest (inc total-nodes-visited) depth))\n            ;; this node failed the test, so check if it has children,\n            ;; if so, traverse down them. If not, save this as the best example\n            ;; seen now and then look at the right-siblings\n            ;; children\n            (let [new-smallest (rose/root head)]\n              (reporter-fn (assoc-in reporter-fn-arg\n                                     [:shrinking :smallest]\n                                     (:args new-smallest)))\n              (if-let [children (seq (rose/children head))]\n                (recur children new-smallest (inc total-nodes-visited) (inc depth))\n                (recur tail new-smallest (inc total-nodes-visited) depth)))))))))\n\n(defn- failure\n  [property failing-rose-tree trial-number size seed start-time reporter-fn]\n  (let [failed-after-ms (- (get-current-time-millis) start-time)\n        root (rose/root failing-rose-tree)\n        result (:result root)\n        failure-data {:fail            (:args root)\n                      :failing-size    size\n                      :num-tests       trial-number\n                      :pass?           false\n                      :property        property\n                      :result          (legacy-result result)\n                      :result-data     (results/result-data result)\n                      :failed-after-ms failed-after-ms\n                      :seed            seed}]\n\n    (reporter-fn (assoc failure-data :type :failure))\n\n    (let [shrunk (shrink-loop failing-rose-tree\n                              #(reporter-fn (merge failure-data %)))]\n      (reporter-fn (assoc failure-data\n                          :type :shrunk\n                          :shrunk shrunk))\n      (-> failure-data\n          (dissoc :property)\n          (assoc :shrunk shrunk)))))\n","~:reader-features",["^N",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["clojure.test.check/make-rng","seed","clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1","non-nil-seed","clojure.test.check.impl/get-current-time-millis","clojure.test.check/complete","property","num-trials","start-time","reporter-fn","time-elapsed-ms","G__69424","clojure.test.check/legacy-result","result","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","clojure.test.check.results/Result","d","clojure.test.check.results/result-data","temp__5751__auto__","vec__69440","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","_","e","cljs.core/find","js/Error","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3","clojure.test.check.results/pass?","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","clojure.test.check/quick-check","p__69454","map__69455","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core.get.cljs$core$IFn$_invoke$arity$3","seq69449","G__69450","cljs.core/first","cljs.core/next","G__69451","self__4717__auto__","num-tests","max-size","cljs.core/constantly","vec__69463","created-seed","rng","size-seq","clojure.test.check.generators/make-size-range-seq","so-far","rstate","vec__69488","seq__69489","cljs.core/seq","first__69490","vec__69491","size","rest-size-seq","r1","r2","clojure.test.check.random/split","result-map-rose","clojure.test.check.generators/call-gen","result-map","clojure.test.check.rose-tree/root","args","G__69500","clojure.test.check/failure","clojure.test.check/smallest-shrink","total-nodes-visited","depth","smallest","map__69512","clojure.test.check/shrink-loop","rose-tree","shrinks-this-depth","clojure.test.check.rose-tree/children","nodes","current-smallest","cljs.core/empty?","head","tail","cljs.core/rest","pass?","reporter-fn-arg","cljs.core/boolean","new-smallest","G__69543","cljs.core/assoc-in","children","failing-rose-tree","trial-number","failed-after-ms","root","failure-data","G__69568","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","shrunk","p1__69552#","G__69571","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","G__69573","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2"]]],"~:cache-keys",["~#cmap",[["^1A","goog/math/math.js"],[1630228359392,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^N",[]],"~:deps-syms",["^[","~$goog.array","~$goog.asserts"]]],["^1A","goog/array/array.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^1S"]]],["^1A","clojure/test/check/generators.cljc"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C","~$clojure.string","^11","^W","~$goog.string"]]],["^1A","goog/debug/error.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^["]]],["^1A","clojure/test/check/random/doubles.cljs"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C","~$clojure.test.check.random.longs"]]],["^1A","goog/dom/nodetype.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^["]]],["^1A","clojure/test/check/rose_tree.cljc"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C"]]],["^1A","clojure/test/check/impl.cljc"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C"]]],["^1A","clojure/test/check/random.cljs"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C","~$clojure.test.check.random.doubles","^1V"]]],["^1A","goog/object/object.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^["]]],"~:SHADOW-TIMESTAMP",[1630228360000,1630228118000],["^1A","goog/math/long.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^1S","~$goog.reflect"]]],["^1A","goog/string/internal.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^["]]],["^1A","clojure/test/check.cljc"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C","^Z","^11","^U","^W","^Y"]]],["^1A","goog/functions/functions.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^["]]],["^1A","goog/structs/map.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1A","goog/asserts/asserts.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1A","goog/uri/uri.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^1R","^1S","^1U","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1A","goog/base.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",[]]],["^1A","goog/structs/structs.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^1R","~$goog.object"]]],["^1A","clojure/string.cljs"],[1630228118934,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C","^1U","~$goog.string.StringBuffer"]]],["^1A","clojure/test/check/random/longs/bit_count_impl.cljs"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C"]]],["^1A","goog/string/string.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","~$goog.string.internal"]]],["^1A","goog/reflect/reflect.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^["]]],["^1A","goog/string/stringbuffer.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^["]]],["^1A","goog/iter/iter.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^1R","^1S","~$goog.functions","~$goog.math"]]],["^1A","cljs/core.cljs"],[1630228118934,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["~$goog.math.Long","~$goog.math.Integer","^1U","^27","^1R","~$goog.Uri","^28"]]],["^1A","clojure/test/check/random/longs.cljs"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C","~$clojure.test.check.random.longs.bit-count-impl","^2<","^C"]]],["^1A","goog/math/integer.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^["]]],["^1A","goog/uri/utils.js"],[1630228359392,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^1R","^1S","^1U"]]],["^1A","clojure/test/check/results.cljc"],[1630228119162,"^1N",["^ ","^1O",null,"^1P",["^N",[]],"^1Q",["^[","^C"]]]]],"~:clj-info",["^ ","jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/edn.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/string.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/analyzer.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/util.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/externs.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/test.check/0.10.0-alpha4/test.check-0.10.0-alpha4.jar!/clojure/test/check/random.clj",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/compiler.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/default_data_readers.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map/base64_vlq.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/core.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/env.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/core.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/js_deps.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/test.check/0.10.0-alpha4/test.check-0.10.0-alpha4.jar!/clojure/test/check/generators.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/instant.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/set.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/data.json/0.2.6/data.json-0.2.6.jar!/clojure/data/json.clj",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/inspect.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/errors.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/java/io.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/test.check/0.10.0-alpha4/test.check-0.10.0-alpha4.jar!/clojure/test/check/rose_tree.cljc",1630228119000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/pprint.clj",1629997474000,"jar:file:/Users/mazeboard/.m2/repository/binaryage/devtools/0.9.10/devtools-0.9.10.jar!/devtools/defaults.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/reader_types.clj",1630228358000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/tagged_literals.cljc",1630228118000,"jar:file:/Users/mazeboard/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map/base64.clj",1630228118000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/test/check.cljc","^7",10,"^8",5,"^9",10,"^:",23],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K"],"^L",null,"^M",["^N",[]],"^O","^P","^S",null,"^T",["^ ","^U","^U","^V","^W","^X","^U","^Y","^Y","^W","^W","^C","^C","^Z","^Z","^[","^[","^10","^Z","^11","^11","^12","^11"],"^13",["^N",["^14"]],"~:shadow/js-access-global",["^N",["Error"]],"^15",["^ ","^16","^Y"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",157,"^8",8,"^9",157,"^:",19,"~:private",true,"~:arglists",["^19",["~$quote",["^19",[["~$rose-tree","~$reporter-fn"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"^36",true,"^O","~$clojure.test.check/shrink-loop","^6","clojure/test/check.cljc","^:",19,"~:method-params",["^19",[["^39","^3:"]]],"~:protocol-impl",null,"~:arglists-meta",["^19",[null,null]],"^8",1,"~:variadic?",false,"^7",157,"~:ret-tag","~$cljs.core/IMap","^9",157,"~:max-fixed-arity",2,"~:fn-var",true,"^37",["^19",["^38",["^19",[["^39","^3:"]]]]],"^3;","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"~$failure",["^ ","^35",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",212,"^8",8,"^9",212,"^:",15,"^36",true,"^37",["^19",["^38",["^19",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed","~$start-time","^3:"]]]]]],"^36",true,"^O","~$clojure.test.check/failure","^6","clojure/test/check.cljc","^:",15,"^3=",["^19",[["^3F","^3G","^3H","^3I","^3J","^3K","^3:"]]],"^3>",null,"^3?",["^19",[null,null]],"^8",1,"^3@",false,"^7",212,"^3A",["^N",["~$clj","~$any"]],"^9",212,"^3C",7,"^3D",true,"^37",["^19",["^38",["^19",[["^3F","^3G","^3H","^3I","^3J","^3K","^3:"]]]]]],"~$make-rng",["^ ","^35",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",19,"^8",8,"^9",19,"^:",16,"^36",true,"^37",["^19",["^38",["^19",[["^3J"]]]]]],"^36",true,"^O","~$clojure.test.check/make-rng","^6","clojure/test/check.cljc","^:",16,"^3=",["^19",[["^3J"]]],"^3>",null,"^3?",["^19",[null,null]],"^8",1,"^3@",false,"^7",19,"^3A","~$cljs.core/IVector","^9",19,"^3C",1,"^3D",true,"^37",["^19",["^38",["^19",[["^3J"]]]]]],"~$complete",["^ ","^35",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",26,"^8",8,"^9",26,"^:",16,"^36",true,"^37",["^19",["^38",["^19",[["^3F","~$num-trials","^3J","^3K","^3:"]]]]]],"^36",true,"^O","~$clojure.test.check/complete","^6","clojure/test/check.cljc","^:",16,"^3=",["^19",[["^3F","^3S","^3J","^3K","^3:"]]],"^3>",null,"^3?",["^19",[null,null]],"^8",1,"^3@",false,"^7",26,"^3A","^3B","^9",26,"^3C",5,"^3D",true,"^37",["^19",["^38",["^19",[["^3F","^3S","^3J","^3K","^3:"]]]]]],"~$legacy-result",["^ ","^35",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",43,"^8",17,"^9",43,"^:",30,"^36",true,"^37",["^19",["^38",["^19",[["~$result"]]]]],"^3;","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"^36",true,"^O","~$clojure.test.check/legacy-result","^6","clojure/test/check.cljc","^:",30,"^3=",["^19",[["^3V"]]],"^3>",null,"^3?",["^19",[null,null]],"^8",1,"^3@",false,"^7",43,"^3A",["^N",[null,"^3N","~$cljs.core/ExceptionInfo","~$clj-nil"]],"^9",43,"^3C",1,"^3D",true,"^37",["^19",["^38",["^19",[["^3V"]]]]],"^3;","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"~$quick-check",["^ ","^35",null,"^5",["^ ","^6","clojure/test/check.cljc","^:",18,"~:top-fn",["^ ","^3@",true,"~:fixed-arity",2,"^3C",2,"^3=",[["^19",["~$num-tests","^3F",["^ ","~:keys",["^3J","~$max-size","^3:"],"~:or",["^ ","^43",200,"^3:",["^19",["~$constantly",null]]]]]]],"^37",["^19",[["^41","^3F","~$&",["^ ","^42",["^3J","^43","^3:"],"^44",["^ ","^43",200,"^3:",["^19",["^45",null]]]]]]],"^3?",["^19",[null]]],"^8",7,"^7",59,"^9",59,"^37",["^19",["^38",["^19",[["^41","^3F","~$&",["^ ","^42",["^3J","^43","^3:"],"^44",["^ ","^43",200,"^3:",["^19",["^45",null]]]]]]]]],"^3;","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","~:jsdoc",["^19",["@param {...*} var_args"]]],"^O","~$clojure.test.check/quick-check","^6","clojure/test/check.cljc","^:",18,"^3[",["^ ","^3@",true,"^40",2,"^3C",2,"^3=",[["^19",["^41","^3F",["^ ","^42",["^3J","^43","^3:"],"^44",["^ ","^43",200,"^3:",["^19",["^45",null]]]]]]],"^37",["^19",[["^41","^3F","~$&",["^ ","^42",["^3J","^43","^3:"],"^44",["^ ","^43",200,"^3:",["^19",["^45",null]]]]]]],"^3?",["^19",[null]]],"^3=",[["^19",["^41","^3F",["^ ","^42",["^3J","^43","^3:"],"^44",["^ ","^43",200,"^3:",["^19",["^45",null]]]]]]],"^3>",null,"^40",2,"^3?",["^19",[null]],"^8",1,"^3@",true,"~:methods",[["^ ","^40",2,"^3@",true,"~:tag",["^N",["^3N","^3B"]]]],"^7",59,"^3A","^3N","^9",59,"^3C",2,"^3D",true,"^37",["^19",[["^41","^3F","~$&",["^ ","^42",["^3J","^43","^3:"],"^44",["^ ","^43",200,"^3:",["^19",["^45",null]]]]]]],"^3;","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","^46",["^19",["@param {...*} var_args"]]],"~$smallest-shrink",["^ ","^35",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",146,"^8",8,"^9",146,"^:",23,"^36",true,"^37",["^19",["^38",["^19",[["~$total-nodes-visited","~$depth","~$smallest","^3K"]]]]]],"^36",true,"^O","~$clojure.test.check/smallest-shrink","^6","clojure/test/check.cljc","^:",23,"^3=",["^19",[["^4;","^4<","^4=","^3K"]]],"^3>",null,"^3?",["^19",[null,null]],"^8",1,"^3@",false,"^7",146,"^3A","^3B","^9",146,"^3C",4,"^3D",true,"^37",["^19",["^38",["^19",[["^4;","^4<","^4=","^3K"]]]]]]],"^17",["^ ","^C","^C","^Z","^Z","^10","^Z"],"~:cljs.analyzer/constants",["^ ","^13",["^N",["~:args","~:clojure.test.check.properties/error","~:shrunk","~:failed-after-ms","~:total-nodes-visited","~:num-tests-total","~:failure","~:property","~:shrink-step","~:num-tests","~:type","~:max-size","~:seed","~:fail","~:result","~:result-data","~:smallest","~:trial","~:time-shrinking-ms","~:failing-size","~:reporter-fn","~:pass?","~:depth","~:complete","~:shrinking","~:time-elapsed-ms"]],"~:order",["^4J","^4G","^4N","^4U","^4I","^4Y","^4L","^4W","^4A","^4K","^4T","^4@","^4E","^4O","^4Q","^4D","^4V","^4R","^4P","^4X","^4H","^4C","^4M","^4S","^4F","^4B"]],"^1=",["^ ","^14",["^N",[]]],"^1>",["^ "],"^1?",["^[","^C","^Z","^11","^U","^W","^Y"]],"^R","^P","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1M",[["^51","~:static-fns"],true,["^51","~:elide-asserts"],true,["^51","~:optimize-constants"],null,["^51","^1D"],null,["^51","~:external-config"],null,["^51","~:tooling-config"],null,["^51","~:emit-constants"],null,["^51","~:load-tests"],false,["^51","~:form-size-threshold"],null,["^51","~:infer-externs"],true,["^51","^1F"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^51","~:fn-invoke-direct"],null,["^51","~:source-map"],"/dev/null"]]]