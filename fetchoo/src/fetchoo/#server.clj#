(ns fetchoo.core
  (:require [org.apache.spark.sql SparkSession]
            [org.apache.spark SparkConf]
            [com.typesafe.config Config ConfigValue]
            [ring.adapter.jetty :as jetty]
            [ring-jetty.util.ws :as ws]
            [muuntaja.core :as m]
            [reitit.ring :as ring]
            [reitit.coercion.spec]
            [reitit.ring.coercion :as rrc]
            [reitit.ring.middleware.muuntaja :as muuntaja]
            [reitit.ring.middleware.parameters :as parameters]
            [cheshire.core :refer :all]))

(defn createTempViews [spark elasticsearchConfig]
  )

(defn runSql [spark sessionId query]
  "inprogress"
  )

(defn fetchWS [app spark]
  (let [contexts (java.util.ArrayList.)] ;WsConnectContext
    (.ws app "/sql"
         (fn [ws] 
           (.onConnect ws
                       (fn [ctx] 
                         (.add contexts ctx)
                         (println "ws connection open")))
           
           (.onClose ws
                     (fn [ctx]
                       (println (.reason ctx))
                       (println "ws connection closed")))
            
           (.onError ws
                     (fn [errctx] 
                       (println (.error errctx))))
            
           (.onMessage ws
                       (fn [ctx]
                         (println "received message: " (.message ctx))
                         (try 
                           (let [msgJson (json/decode (.message ctx) true)]
                             (println "json message: " (.toString msgJson))
                             (let [query (:query msgJson)
                                   sessionId (:sessionId msgJson)]
                               (println query)
                               (println "sessionId" sessionId)
                               (.schedule (Executors.newSingleThreadScheduledExecutor)
                                          (fn []
                                            (try 
                                              (.send ctx (runSql spark sessionId query))
                                              (catch Exception e 
                                                (let [msg (.getMessage e)]
                                                  (.send ctx (json/encode {
                                                                           :error msg
                                                                           :stacktrace (.getStackTrace e)
                                                                           }))))))
                                          0 (.MILLISECONDS TimeUnit))
                               
                               (.send ctx
                                      (json/encode {
                                                    :error "request must include sessionId and query fields"
                                                    }))))
                           (catch Exception e
                             (.send ctx (str (json/encode {
                                                    :error (.getMessage e)
                                                    })))))))
           ))))

(defn startServer [config]
  (let [httpConf (.getConfig config "http")
        sparkConf (let [sparkConf (SparkConf.)]
                    (doseq [[key value] (.entrySet (.getConfig config "sparkConf"))]
                      (.set sparkConf
                            ^String key
                            (.toString (.unwrapped value))))
                    sparkConf)
        app (ring/ring-handler
             (ring/router
              ["/api"
               ["/math" {:get {:parameters {:query {:x int?, :y int?}}
                               :responses  {200 {:body {:total int?}}}
                               :handler    (fn [{{{:keys [x y]} :query} :parameters}]
                                             {:status 200
                                              :body   {:total (+ x y)}})}}]]
              ;; router data affecting all routes
              {:data {:coercion   reitit.coercion.spec/coercion
                      :muuntaja   m/instance
                      :middleware [parameters/parameters-middleware
                                   rrc/coerce-request-middleware
                                   rrc/coerce-response-middleware
                                   muuntaja/format-response-middleware]}}))
        spark (.getOrCreate (.config (SparkSession/builder) sparkConf))]
    (createTempViews spark (.getConfig config "elasticsearch"))
    (fetchWS app spark)
    (jetty/run-jetty app {:port (.getInt httpConf)})
    ))

          
        

